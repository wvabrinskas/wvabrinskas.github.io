{"variants":[{"paths":["\/documentation\/atomics\/atomicreference"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"modules":[{"name":"Atomics"}],"externalID":"s:7Atomics15AtomicReferenceP","roleHeading":"Protocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AtomicReference"}],"role":"symbol","title":"AtomicReference","navigatorTitle":[{"text":"AtomicReference","kind":"identifier"}],"symbolKind":"protocol"},"relationshipsSections":[{"type":"inheritsFrom","identifiers":["doc:\/\/com.wvabrinskas.Neuron\/documentation\/Atomics\/AtomicOptionalWrappable","doc:\/\/com.wvabrinskas.Neuron\/documentation\/Atomics\/AtomicValue"],"kind":"relationships","title":"Inherits From"}],"hierarchy":{"paths":[["doc:\/\/com.wvabrinskas.Neuron\/documentation\/Atomics"]]},"abstract":[{"type":"text","text":"A class type that supports atomic strong references."}],"primaryContentSections":[{"declarations":[{"languages":["swift"],"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AtomicReference"},{"kind":"text","text":" : AnyObject, "},{"preciseIdentifier":"s:7Atomics23AtomicOptionalWrappableP","kind":"typeIdentifier","identifier":"doc:\/\/com.wvabrinskas.Neuron\/documentation\/Atomics\/AtomicOptionalWrappable","text":"AtomicOptionalWrappable"}],"platforms":["macOS"]}],"kind":"declarations"},{"kind":"content","content":[{"text":"Overview","anchor":"overview","type":"heading","level":2},{"code":["class MyObject: AtomicReference {}","","let object = MyObject()","let ref = ManagedAtomic<MyObject>(object)","","ref.load(ordering: .relaxed) \/\/ Returns `object`."],"type":"codeListing","syntax":null},{"inlineContent":[{"text":"The conforming class is allowed to be non-final, but ","type":"text"},{"code":"ManagedAtomic","type":"codeVoice"},{"text":" and","type":"text"},{"text":" ","type":"text"},{"code":"UnsafeAtomic","type":"codeVoice"},{"text":" do not support using a subclass as their generic argument â€“","type":"text"},{"text":" ","type":"text"},{"text":"the type of an atomic reference must be precisely the same class that","type":"text"},{"text":" ","type":"text"},{"text":"originally conformed to the protocol.","type":"text"}],"type":"paragraph"},{"code":["class Derived: MyObject {}","","let ref2: ManagedAtomic<Derived>","\/\/ error: 'ManagedAtomic' requires the types 'Derived' and 'Base' be equivalent"],"type":"codeListing","syntax":null},{"inlineContent":[{"text":"Note that this limitation only affects the static type of the","type":"text"},{"text":" ","type":"text"},{"code":"ManagedAtomic","type":"codeVoice"},{"text":"\/","type":"text"},{"code":"UnsafeAtomic","type":"codeVoice"},{"text":" variables. Such references still fully","type":"text"},{"text":" ","type":"text"},{"text":"support holding instances of subclasses of the conforming class. (Returned","type":"text"},{"text":" ","type":"text"},{"text":"may be downcasted from the base type after an ","type":"text"},{"code":"is","type":"codeVoice"},{"text":" check.)","type":"text"}],"type":"paragraph"},{"code":["let child = Derived()","ref.store(child, ordering: .relaxed) \/\/ OK!","let value = ref.load(ordering: .relaxed)","\/\/ `value` is a variable of type `MyObject`, holding a `Derived` instance.","print(value is Derived) \/\/ Prints \"true\""],"type":"codeListing","syntax":null}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.wvabrinskas.Neuron\/documentation\/Atomics\/AtomicReference"},"kind":"symbol","sections":[],"references":{"doc://com.wvabrinskas.Neuron/documentation/Atomics/AtomicReference":{"url":"\/documentation\/atomics\/atomicreference","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AtomicReference","kind":"identifier"}],"role":"symbol","abstract":[{"type":"text","text":"A class type that supports atomic strong references."}],"title":"AtomicReference","identifier":"doc:\/\/com.wvabrinskas.Neuron\/documentation\/Atomics\/AtomicReference","navigatorTitle":[{"text":"AtomicReference","kind":"identifier"}],"type":"topic","kind":"symbol"},"doc://com.wvabrinskas.Neuron/documentation/Atomics/AtomicValue":{"identifier":"doc:\/\/com.wvabrinskas.Neuron\/documentation\/Atomics\/AtomicValue","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AtomicValue","kind":"identifier"}],"title":"AtomicValue","type":"topic","kind":"symbol","navigatorTitle":[{"text":"AtomicValue","kind":"identifier"}],"abstract":[{"type":"text","text":"A type that supports atomic operations through a separate atomic storage"},{"type":"text","text":" "},{"type":"text","text":"representation."}],"role":"symbol","url":"\/documentation\/atomics\/atomicvalue"},"doc://com.wvabrinskas.Neuron/documentation/Atomics":{"role":"collection","url":"\/documentation\/atomics","type":"topic","kind":"symbol","identifier":"doc:\/\/com.wvabrinskas.Neuron\/documentation\/Atomics","abstract":[],"title":"Atomics"},"doc://com.wvabrinskas.Neuron/documentation/Atomics/AtomicOptionalWrappable":{"url":"\/documentation\/atomics\/atomicoptionalwrappable","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AtomicOptionalWrappable","kind":"identifier"}],"role":"symbol","abstract":[{"type":"text","text":"An atomic value that also supports atomic operations when wrapped"},{"type":"text","text":" "},{"type":"text","text":"in an "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":". Atomic optional wrappable types come with a"},{"type":"text","text":" "},{"type":"text","text":"standalone atomic representation for their optional-wrapped"},{"type":"text","text":" "},{"type":"text","text":"variants."}],"title":"AtomicOptionalWrappable","identifier":"doc:\/\/com.wvabrinskas.Neuron\/documentation\/Atomics\/AtomicOptionalWrappable","navigatorTitle":[{"text":"AtomicOptionalWrappable","kind":"identifier"}],"type":"topic","kind":"symbol"}}}