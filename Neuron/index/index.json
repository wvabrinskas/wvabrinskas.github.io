{"includedArchiveIdentifiers":["com.wvabrinskas.Neuron"],"interfaceLanguages":{"swift":[{"children":[{"title":"Classes","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/managedatomic\/init(_:)","title":"init(Value)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/managedatomic\/bitwiseandthenload(with:ordering:)","title":"func bitwiseAndThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/bitwiseorthenload(with:ordering:)","title":"func bitwiseOrThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/bitwisexorthenload(with:ordering:)","title":"func bitwiseXorThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/compareexchange(expected:desired:ordering:)","title":"func compareExchange(expected: Value, desired: Value, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/compareexchange(expected:desired:successordering:failureordering:)","title":"func compareExchange(expected: Value, desired: Value, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/exchange(_:ordering:)","title":"func exchange(Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/load(ordering:)","title":"func load(ordering: AtomicLoadOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/loadthenbitwiseand(with:ordering:)","title":"func loadThenBitwiseAnd(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/loadthenbitwiseor(with:ordering:)","title":"func loadThenBitwiseOr(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/loadthenbitwisexor(with:ordering:)","title":"func loadThenBitwiseXor(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/loadthenlogicaland(with:ordering:)","title":"func loadThenLogicalAnd(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/loadthenlogicalor(with:ordering:)","title":"func loadThenLogicalOr(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/loadthenlogicalxor(with:ordering:)","title":"func loadThenLogicalXor(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/loadthenwrappingdecrement(by:ordering:)","title":"func loadThenWrappingDecrement(by: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/loadthenwrappingincrement(by:ordering:)","title":"func loadThenWrappingIncrement(by: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/logicalandthenload(with:ordering:)","title":"func logicalAndThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/logicalorthenload(with:ordering:)","title":"func logicalOrThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/logicalxorthenload(with:ordering:)","title":"func logicalXorThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/store(_:ordering:)","title":"func store(Value, ordering: AtomicStoreOrdering)","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/weakcompareexchange(expected:desired:ordering:)","title":"func weakCompareExchange(expected: Value, desired: Value, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/weakcompareexchange(expected:desired:successordering:failureordering:)","title":"func weakCompareExchange(expected: Value, desired: Value, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/wrappingdecrement(by:ordering:)","title":"func wrappingDecrement(by: Value, ordering: AtomicUpdateOrdering)","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/wrappingdecrementthenload(by:ordering:)","title":"func wrappingDecrementThenLoad(by: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/wrappingincrement(by:ordering:)","title":"func wrappingIncrement(by: Value, ordering: AtomicUpdateOrdering)","type":"method"},{"path":"\/documentation\/atomics\/managedatomic\/wrappingincrementthenload(by:ordering:)","title":"func wrappingIncrementThenLoad(by: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"}],"path":"\/documentation\/atomics\/managedatomic","title":"ManagedAtomic","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/managedatomiclazyreference\/init()","title":"init()","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/managedatomiclazyreference\/load()","title":"func load() -> Instance?","type":"method"},{"path":"\/documentation\/atomics\/managedatomiclazyreference\/storeifnilthenload(_:)","title":"func storeIfNilThenLoad(Instance) -> Instance","type":"method"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/atomics\/managedatomiclazyreference\/value","title":"ManagedAtomicLazyReference.Value","type":"typealias"}],"path":"\/documentation\/atomics\/managedatomiclazyreference","title":"ManagedAtomicLazyReference","type":"class"},{"title":"Protocols","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicinteger","title":"AtomicInteger","type":"protocol"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicintegerstorage\/atomicloadthenbitwiseand(with:at:ordering:)","title":"static func atomicLoadThenBitwiseAnd(with: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicintegerstorage\/atomicloadthenbitwiseor(with:at:ordering:)","title":"static func atomicLoadThenBitwiseOr(with: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicintegerstorage\/atomicloadthenbitwisexor(with:at:ordering:)","title":"static func atomicLoadThenBitwiseXor(with: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicintegerstorage\/atomicloadthenwrappingdecrement(by:at:ordering:)","title":"static func atomicLoadThenWrappingDecrement(by: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicintegerstorage\/atomicloadthenwrappingincrement(by:at:ordering:)","title":"static func atomicLoadThenWrappingIncrement(by: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> Value","type":"method"}],"path":"\/documentation\/atomics\/atomicintegerstorage","title":"AtomicIntegerStorage","type":"protocol"},{"children":[{"title":"Associated Types","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalwrappable\/atomicoptionalrepresentation","title":"AtomicOptionalRepresentation","type":"associatedtype"}],"path":"\/documentation\/atomics\/atomicoptionalwrappable","title":"AtomicOptionalWrappable","type":"protocol"},{"path":"\/documentation\/atomics\/atomicreference","title":"AtomicReference","type":"protocol"},{"children":[{"title":"Associated Types","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicstorage\/value","title":"Value","type":"associatedtype"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicstorage\/init(_:)","title":"init(Value)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicstorage\/dispose()","title":"func dispose() -> Value","type":"method"},{"title":"Type Methods","type":"groupMarker"},{"children":[{"children":[{"path":"\/documentation\/atomics\/atomicstorage\/atomiccompareexchange(expected:desired:at:ordering:)-zf4","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"}],"title":"AtomicStorage Implementations","type":"groupMarker"}],"path":"\/documentation\/atomics\/atomicstorage\/atomiccompareexchange(expected:desired:at:ordering:)","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicstorage\/atomiccompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicstorage\/atomicexchange(_:at:ordering:)","title":"static func atomicExchange(Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicstorage\/atomicload(at:ordering:)","title":"static func atomicLoad(at: UnsafeMutablePointer<Self>, ordering: AtomicLoadOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicstorage\/atomicstore(_:at:ordering:)","title":"static func atomicStore(Value, at: UnsafeMutablePointer<Self>, ordering: AtomicStoreOrdering)","type":"method"},{"children":[{"children":[{"path":"\/documentation\/atomics\/atomicstorage\/atomicweakcompareexchange(expected:desired:at:ordering:)-2et7j","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"}],"title":"AtomicStorage Implementations","type":"groupMarker"}],"path":"\/documentation\/atomics\/atomicstorage\/atomicweakcompareexchange(expected:desired:at:ordering:)","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicstorage\/atomicweakcompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"}],"path":"\/documentation\/atomics\/atomicstorage","title":"AtomicStorage","type":"protocol"},{"children":[{"title":"Associated Types","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicvalue\/atomicrepresentation","title":"AtomicRepresentation","type":"associatedtype"}],"path":"\/documentation\/atomics\/atomicvalue","title":"AtomicValue","type":"protocol"},{"title":"Structures","type":"groupMarker"},{"children":[{"title":"Type Properties","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicloadordering\/acquiring","title":"static var acquiring: `Self`","type":"property"},{"path":"\/documentation\/atomics\/atomicloadordering\/relaxed","title":"static var relaxed: `Self`","type":"property"},{"path":"\/documentation\/atomics\/atomicloadordering\/sequentiallyconsistent","title":"static var sequentiallyConsistent: `Self`","type":"property"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicloadordering\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/atomics\/atomicloadordering\/customstringconvertible-implementations","title":"CustomStringConvertible Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicloadordering\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"},{"path":"\/documentation\/atomics\/atomicloadordering\/==(_:_:)","title":"static func == (`Self`, `Self`) -> Bool","type":"op"}],"path":"\/documentation\/atomics\/atomicloadordering\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicloadordering\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/atomics\/atomicloadordering\/hashable-implementations","title":"Hashable Implementations","type":"symbol"}],"path":"\/documentation\/atomics\/atomicloadordering","title":"AtomicLoadOrdering","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/init(_:)","title":"init(Optional<Wrapped>)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/dispose()","title":"func dispose() -> Optional<Wrapped>","type":"method"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/value","title":"AtomicOptionalRawRepresentableStorage.Value","type":"typealias"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/atomiccompareexchange(expected:desired:at:ordering:)","title":"static func atomicCompareExchange(expected: Optional<Wrapped>, desired: Optional<Wrapped>, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Optional<Wrapped>)","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/atomiccompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicCompareExchange(expected: Optional<Wrapped>, desired: Optional<Wrapped>, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Optional<Wrapped>)","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/atomicexchange(_:at:ordering:)","title":"static func atomicExchange(Optional<Wrapped>, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> Optional<Wrapped>","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/atomicload(at:ordering:)","title":"static func atomicLoad(at: UnsafeMutablePointer<`Self`>, ordering: AtomicLoadOrdering) -> Optional<Wrapped>","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/atomicstore(_:at:ordering:)","title":"static func atomicStore(Optional<Wrapped>, at: UnsafeMutablePointer<`Self`>, ordering: AtomicStoreOrdering)","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/atomicweakcompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicWeakCompareExchange(expected: Optional<Wrapped>, desired: Optional<Wrapped>, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Optional<Wrapped>)","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/atomiccompareexchange(expected:desired:at:ordering:)-hgj4","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/atomicweakcompareexchange(expected:desired:at:ordering:)","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"}],"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage\/atomicstorage-implementations","title":"AtomicStorage Implementations","type":"symbol"}],"path":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage","title":"AtomicOptionalRawRepresentableStorage","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/init(_:)","title":"init(Instance?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/dispose()","title":"func dispose() -> Instance?","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/value","title":"AtomicOptionalReferenceStorage.Value","type":"typealias"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/atomiccompareexchange(expected:desired:at:ordering:)","title":"static func atomicCompareExchange(expected: Instance?, desired: Instance?, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Instance?)","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/atomiccompareexchange(expected:desired:at:ordering:)-6g995","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/atomiccompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicCompareExchange(expected: Instance?, desired: Instance?, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Instance?)","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/atomicexchange(_:at:ordering:)","title":"static func atomicExchange(Instance?, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> Instance?","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/atomicload(at:ordering:)","title":"static func atomicLoad(at: UnsafeMutablePointer<`Self`>, ordering: AtomicLoadOrdering) -> Instance?","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/atomicstore(_:at:ordering:)","title":"static func atomicStore(Instance?, at: UnsafeMutablePointer<`Self`>, ordering: AtomicStoreOrdering)","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/atomicweakcompareexchange(expected:desired:at:ordering:)","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/atomicweakcompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicWeakCompareExchange(expected: Instance?, desired: Instance?, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Instance?)","type":"method"}],"path":"\/documentation\/atomics\/atomicoptionalreferencestorage\/atomicstorage-implementations","title":"AtomicStorage Implementations","type":"symbol"}],"path":"\/documentation\/atomics\/atomicoptionalreferencestorage","title":"AtomicOptionalReferenceStorage","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/init(_:)","title":"init(Value)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/dispose()","title":"func dispose() -> Value","type":"method"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/atomiccompareexchange(expected:desired:at:ordering:)","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/atomiccompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/atomicexchange(_:at:ordering:)","title":"static func atomicExchange(Value, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/atomicload(at:ordering:)","title":"static func atomicLoad(at: UnsafeMutablePointer<`Self`>, ordering: AtomicLoadOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/atomicstore(_:at:ordering:)","title":"static func atomicStore(Value, at: UnsafeMutablePointer<`Self`>, ordering: AtomicStoreOrdering)","type":"method"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/atomicweakcompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/atomiccompareexchange(expected:desired:at:ordering:)-6itii","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/atomicweakcompareexchange(expected:desired:at:ordering:)","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"}],"path":"\/documentation\/atomics\/atomicrawrepresentablestorage\/atomicstorage-implementations","title":"AtomicStorage Implementations","type":"symbol"}],"path":"\/documentation\/atomics\/atomicrawrepresentablestorage","title":"AtomicRawRepresentableStorage","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/init(_:)","title":"init(Value)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/dispose()","title":"func dispose() -> Value","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/atomiccompareexchange(expected:desired:at:ordering:)","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/atomiccompareexchange(expected:desired:at:ordering:)-1u5rc","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/atomiccompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/atomicexchange(_:at:ordering:)","title":"static func atomicExchange(Value, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/atomicload(at:ordering:)","title":"static func atomicLoad(at: UnsafeMutablePointer<`Self`>, ordering: AtomicLoadOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/atomicstore(_:at:ordering:)","title":"static func atomicStore(Value, at: UnsafeMutablePointer<`Self`>, ordering: AtomicStoreOrdering)","type":"method"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/atomicweakcompareexchange(expected:desired:at:ordering:)","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/atomicreferencestorage\/atomicweakcompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"}],"path":"\/documentation\/atomics\/atomicreferencestorage\/atomicstorage-implementations","title":"AtomicStorage Implementations","type":"symbol"}],"path":"\/documentation\/atomics\/atomicreferencestorage","title":"AtomicReferenceStorage","type":"struct"},{"children":[{"title":"Type Properties","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicstoreordering\/relaxed","title":"static var relaxed: `Self`","type":"property"},{"path":"\/documentation\/atomics\/atomicstoreordering\/releasing","title":"static var releasing: `Self`","type":"property"},{"path":"\/documentation\/atomics\/atomicstoreordering\/sequentiallyconsistent","title":"static var sequentiallyConsistent: `Self`","type":"property"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicstoreordering\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/atomics\/atomicstoreordering\/customstringconvertible-implementations","title":"CustomStringConvertible Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicstoreordering\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"},{"path":"\/documentation\/atomics\/atomicstoreordering\/==(_:_:)","title":"static func == (`Self`, `Self`) -> Bool","type":"op"}],"path":"\/documentation\/atomics\/atomicstoreordering\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicstoreordering\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/atomics\/atomicstoreordering\/hashable-implementations","title":"Hashable Implementations","type":"symbol"}],"path":"\/documentation\/atomics\/atomicstoreordering","title":"AtomicStoreOrdering","type":"struct"},{"children":[{"title":"Type Properties","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicupdateordering\/acquiring","title":"static var acquiring: `Self`","type":"property"},{"path":"\/documentation\/atomics\/atomicupdateordering\/acquiringandreleasing","title":"static var acquiringAndReleasing: `Self`","type":"property"},{"path":"\/documentation\/atomics\/atomicupdateordering\/relaxed","title":"static var relaxed: `Self`","type":"property"},{"path":"\/documentation\/atomics\/atomicupdateordering\/releasing","title":"static var releasing: `Self`","type":"property"},{"path":"\/documentation\/atomics\/atomicupdateordering\/sequentiallyconsistent","title":"static var sequentiallyConsistent: `Self`","type":"property"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicupdateordering\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/atomics\/atomicupdateordering\/customstringconvertible-implementations","title":"CustomStringConvertible Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicupdateordering\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"},{"path":"\/documentation\/atomics\/atomicupdateordering\/==(_:_:)","title":"static func == (`Self`, `Self`) -> Bool","type":"op"}],"path":"\/documentation\/atomics\/atomicupdateordering\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicupdateordering\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/atomics\/atomicupdateordering\/hashable-implementations","title":"Hashable Implementations","type":"symbol"}],"path":"\/documentation\/atomics\/atomicupdateordering","title":"AtomicUpdateOrdering","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/doubleword\/init(first:second:)","title":"init(first: UInt, second: UInt)","type":"init"},{"path":"\/documentation\/atomics\/doubleword\/init(high:low:)","title":"init(high: UInt, low: UInt)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/atomics\/doubleword\/first","title":"var first: UInt","type":"property"},{"path":"\/documentation\/atomics\/doubleword\/high","title":"var high: UInt","type":"property"},{"path":"\/documentation\/atomics\/doubleword\/low","title":"var low: UInt","type":"property"},{"path":"\/documentation\/atomics\/doubleword\/second","title":"var second: UInt","type":"property"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Structures","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/init(_:)","title":"init(Value)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/dispose()","title":"func dispose() -> Value","type":"method"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/value","title":"DoubleWord.AtomicRepresentation.Value","type":"typealias"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/atomiccompareexchange(expected:desired:at:ordering:)","title":"static func atomicCompareExchange(expected: DoubleWord, desired: DoubleWord, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: DoubleWord)","type":"method"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/atomiccompareexchange(expected:desired:at:ordering:)-iecx","title":"static func atomicCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/atomiccompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicCompareExchange(expected: DoubleWord, desired: DoubleWord, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: DoubleWord)","type":"method"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/atomicexchange(_:at:ordering:)","title":"static func atomicExchange(DoubleWord, at: UnsafeMutablePointer<`Self`>, ordering: AtomicUpdateOrdering) -> DoubleWord","type":"method"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/atomicload(at:ordering:)","title":"static func atomicLoad(at: UnsafeMutablePointer<`Self`>, ordering: AtomicLoadOrdering) -> DoubleWord","type":"method"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/atomicstore(_:at:ordering:)","title":"static func atomicStore(DoubleWord, at: UnsafeMutablePointer<`Self`>, ordering: AtomicStoreOrdering)","type":"method"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/atomicweakcompareexchange(expected:desired:at:ordering:)","title":"static func atomicWeakCompareExchange(expected: Value, desired: Value, at: UnsafeMutablePointer<Self>, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/atomicweakcompareexchange(expected:desired:at:successordering:failureordering:)","title":"static func atomicWeakCompareExchange(expected: DoubleWord, desired: DoubleWord, at: UnsafeMutablePointer<`Self`>, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: DoubleWord)","type":"method"}],"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation\/atomicstorage-implementations","title":"AtomicStorage Implementations","type":"symbol"}],"path":"\/documentation\/atomics\/doubleword\/atomicrepresentation","title":"DoubleWord.AtomicRepresentation","type":"struct"}],"path":"\/documentation\/atomics\/doubleword\/atomicvalue-implementations","title":"AtomicValue Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/atomics\/doubleword\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/atomics\/doubleword\/customstringconvertible-implementations","title":"CustomStringConvertible Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/atomics\/doubleword\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"},{"path":"\/documentation\/atomics\/doubleword\/==(_:_:)","title":"static func == (`Self`, `Self`) -> Bool","type":"op"}],"path":"\/documentation\/atomics\/doubleword\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/doubleword\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/atomics\/doubleword\/hashable-implementations","title":"Hashable Implementations","type":"symbol"}],"path":"\/documentation\/atomics\/doubleword","title":"DoubleWord","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomic\/init(at:)","title":"init(at: UnsafeMutablePointer<Storage>)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomic\/bitwiseandthenload(with:ordering:)","title":"func bitwiseAndThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/bitwiseorthenload(with:ordering:)","title":"func bitwiseOrThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/bitwisexorthenload(with:ordering:)","title":"func bitwiseXorThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/compareexchange(expected:desired:ordering:)","title":"func compareExchange(expected: Value, desired: Value, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/compareexchange(expected:desired:successordering:failureordering:)","title":"func compareExchange(expected: Value, desired: Value, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/destroy()","title":"func destroy() -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/exchange(_:ordering:)","title":"func exchange(Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/load(ordering:)","title":"func load(ordering: AtomicLoadOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/loadthenbitwiseand(with:ordering:)","title":"func loadThenBitwiseAnd(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/loadthenbitwiseor(with:ordering:)","title":"func loadThenBitwiseOr(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/loadthenbitwisexor(with:ordering:)","title":"func loadThenBitwiseXor(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/loadthenlogicaland(with:ordering:)","title":"func loadThenLogicalAnd(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/loadthenlogicalor(with:ordering:)","title":"func loadThenLogicalOr(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/loadthenlogicalxor(with:ordering:)","title":"func loadThenLogicalXor(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/loadthenwrappingdecrement(by:ordering:)","title":"func loadThenWrappingDecrement(by: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/loadthenwrappingincrement(by:ordering:)","title":"func loadThenWrappingIncrement(by: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/logicalandthenload(with:ordering:)","title":"func logicalAndThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/logicalorthenload(with:ordering:)","title":"func logicalOrThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/logicalxorthenload(with:ordering:)","title":"func logicalXorThenLoad(with: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/store(_:ordering:)","title":"func store(Value, ordering: AtomicStoreOrdering)","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/weakcompareexchange(expected:desired:ordering:)","title":"func weakCompareExchange(expected: Value, desired: Value, ordering: AtomicUpdateOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/weakcompareexchange(expected:desired:successordering:failureordering:)","title":"func weakCompareExchange(expected: Value, desired: Value, successOrdering: AtomicUpdateOrdering, failureOrdering: AtomicLoadOrdering) -> (exchanged: Bool, original: Value)","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/wrappingdecrement(by:ordering:)","title":"func wrappingDecrement(by: Value, ordering: AtomicUpdateOrdering)","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/wrappingdecrementthenload(by:ordering:)","title":"func wrappingDecrementThenLoad(by: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/wrappingincrement(by:ordering:)","title":"func wrappingIncrement(by: Value, ordering: AtomicUpdateOrdering)","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomic\/wrappingincrementthenload(by:ordering:)","title":"func wrappingIncrementThenLoad(by: Value, ordering: AtomicUpdateOrdering) -> Value","type":"method"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomic\/storage","title":"UnsafeAtomic.Storage","type":"typealias"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomic\/create(_:)","title":"static func create(Value) -> UnsafeAtomic<Value>","type":"method"}],"path":"\/documentation\/atomics\/unsafeatomic","title":"UnsafeAtomic","type":"struct"},{"children":[{"title":"Structures","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomiclazyreference\/storage\/init()","title":"init()","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomiclazyreference\/storage\/dispose()","title":"func dispose() -> Value","type":"method"}],"path":"\/documentation\/atomics\/unsafeatomiclazyreference\/storage","title":"UnsafeAtomicLazyReference.Storage","type":"struct"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomiclazyreference\/init(at:)","title":"init(at: UnsafeMutablePointer<Storage>)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomiclazyreference\/destroy()","title":"func destroy() -> Value","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomiclazyreference\/load()","title":"func load() -> Instance?","type":"method"},{"path":"\/documentation\/atomics\/unsafeatomiclazyreference\/storeifnilthenload(_:)","title":"func storeIfNilThenLoad(Instance) -> Instance","type":"method"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomiclazyreference\/value","title":"UnsafeAtomicLazyReference.Value","type":"typealias"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/atomics\/unsafeatomiclazyreference\/create()","title":"static func create() -> UnsafeAtomicLazyReference<Instance>","type":"method"}],"path":"\/documentation\/atomics\/unsafeatomiclazyreference","title":"UnsafeAtomicLazyReference","type":"struct"},{"title":"Functions","type":"groupMarker"},{"path":"\/documentation\/atomics\/atomicmemoryfence(ordering:)","title":"func atomicMemoryFence(ordering: AtomicUpdateOrdering)","type":"func"}],"path":"\/documentation\/atomics","title":"Atomics","type":"module"},{"children":[{"title":"Structures","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/init(_:)-4csd3","title":"init<Other>(Other)","type":"init"},{"path":"\/documentation\/complexmodule\/complex\/init(_:)-5aesj","title":"init(RealType)","type":"init"},{"path":"\/documentation\/complexmodule\/complex\/init(_:)-80jml","title":"init<Other>(Complex<Other>)","type":"init"},{"path":"\/documentation\/complexmodule\/complex\/init(_:_:)","title":"init(RealType, RealType)","type":"init"},{"path":"\/documentation\/complexmodule\/complex\/init(exactly:)-767k9","title":"init?<Other>(exactly: Complex<Other>)","type":"init"},{"path":"\/documentation\/complexmodule\/complex\/init(imaginary:)","title":"init(imaginary: RealType)","type":"init"},{"path":"\/documentation\/complexmodule\/complex\/init(length:phase:)","title":"init(length: RealType, phase: RealType)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/canonicalized","title":"var canonicalized: Complex<RealType>","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/conjugate","title":"var conjugate: Complex<RealType>","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/imaginary","title":"var imaginary: RealType","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/isfinite","title":"var isFinite: Bool","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/isnormal","title":"var isNormal: Bool","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/issubnormal","title":"var isSubnormal: Bool","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/iszero","title":"var isZero: Bool","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/length","title":"var length: RealType","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/lengthsquared","title":"var lengthSquared: RealType","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/normalized","title":"var normalized: Complex<RealType>?","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/phase","title":"var phase: RealType","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/polar","title":"var polar: (length: RealType, phase: RealType)","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/rawstorage","title":"var rawStorage: (x: RealType, y: RealType)","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/real","title":"var real: RealType","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/divided(by:)","title":"func divided(by: RealType) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/multiplied(by:)","title":"func multiplied(by: RealType) -> Complex<RealType>","type":"method"},{"title":"Type Properties","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/i","title":"static var i: Complex<RealType>","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/infinity","title":"static var infinity: Complex<RealType>","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/one","title":"static var one: Complex<RealType>","type":"property"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/+(_:)","title":"static func + (Self) -> Self","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/+(_:)","title":"static func + (Self) -> Self","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/+(_:_:)","title":"static func + (Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/+(_:_:)","title":"static func + (Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/+=(_:_:)","title":"static func += (inout Complex<RealType>, Complex<RealType>)","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/+=(_:_:)","title":"static func += (inout Complex<RealType>, Complex<RealType>)","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/+=(_:_:)-247oi","title":"static func += (inout Self, Self)","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/+=(_:_:)-247oi","title":"static func += (inout Self, Self)","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/-(_:_:)","title":"static func - (Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/-(_:_:)","title":"static func - (Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/-=(_:_:)","title":"static func -= (inout Complex<RealType>, Complex<RealType>)","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/-=(_:_:)","title":"static func -= (inout Complex<RealType>, Complex<RealType>)","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/-=(_:_:)-85whw","title":"static func -= (inout Self, Self)","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/-=(_:_:)-85whw","title":"static func -= (inout Self, Self)","type":"op"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/isapproximatelyequal(to:absolutetolerance:relativetolerance:norm:)","title":"func isApproximatelyEqual<Magnitude>(to: Self, absoluteTolerance: Magnitude, relativeTolerance: Magnitude, norm: (Self) -> Magnitude) -> Bool","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/isapproximatelyequal(to:absolutetolerance:relativetolerance:norm:)","title":"func isApproximatelyEqual<Magnitude>(to: Self, absoluteTolerance: Magnitude, relativeTolerance: Magnitude, norm: (Self) -> Magnitude) -> Bool","type":"method"},{"title":"Type Properties","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/zero","title":"static var zero: Complex<RealType>","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/zero","title":"static var zero: Complex<RealType>","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/zero-5ejwo","title":"static var zero: Self","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/zero-5ejwo","title":"static var zero: Self","type":"property"}],"path":"\/documentation\/complexmodule\/complex\/additivearithmetic-implementations","title":"AdditiveArithmetic Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/_(_:_:)","title":"static func \/ (Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/_(_:_:)","title":"static func \/ (Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/_(_:_:)-94u8w","title":"static func \/ (Self, Self) -> Self","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/_(_:_:)-94u8w","title":"static func \/ (Self, Self) -> Self","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/_=(_:_:)","title":"static func \/= (inout Complex<RealType>, Complex<RealType>)","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/_=(_:_:)","title":"static func \/= (inout Complex<RealType>, Complex<RealType>)","type":"op"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/reciprocal","title":"var reciprocal: Complex<RealType>?","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/reciprocal","title":"var reciprocal: Complex<RealType>?","type":"property"}],"path":"\/documentation\/complexmodule\/complex\/algebraicfield-implementations","title":"AlgebraicField Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/debugdescription","title":"var debugDescription: String","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/debugdescription","title":"var debugDescription: String","type":"property"}],"path":"\/documentation\/complexmodule\/complex\/customdebugstringconvertible-implementations","title":"CustomDebugStringConvertible Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/description","title":"var description: String","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/complexmodule\/complex\/customstringconvertible-implementations","title":"CustomStringConvertible Implementations","type":"symbol"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/init(from:)","title":"init(from: any Decoder) throws","type":"init"},{"path":"\/documentation\/complexmodule\/complex\/init(from:)","title":"init(from: any Decoder) throws","type":"init"}],"path":"\/documentation\/complexmodule\/complex\/decodable-implementations","title":"Decodable Implementations","type":"symbol"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/acos(_:)","title":"static func acos(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/acos(_:)","title":"static func acos(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/acosh(_:)","title":"static func acosh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/acosh(_:)","title":"static func acosh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/asin(_:)","title":"static func asin(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/asin(_:)","title":"static func asin(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/asinh(_:)","title":"static func asinh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/asinh(_:)","title":"static func asinh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/atan(_:)","title":"static func atan(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/atan(_:)","title":"static func atan(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/atanh(_:)","title":"static func atanh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/atanh(_:)","title":"static func atanh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/cos(_:)","title":"static func cos(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/cos(_:)","title":"static func cos(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/cosh(_:)","title":"static func cosh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/cosh(_:)","title":"static func cosh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/exp(_:)","title":"static func exp(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/exp(_:)","title":"static func exp(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/expminusone(_:)","title":"static func expMinusOne(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/expminusone(_:)","title":"static func expMinusOne(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/log(_:)","title":"static func log(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/log(_:)","title":"static func log(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/log(oneplus:)","title":"static func log(onePlus: Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/log(oneplus:)","title":"static func log(onePlus: Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/pow(_:_:)-1ylad","title":"static func pow(Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/pow(_:_:)-1ylad","title":"static func pow(Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/pow(_:_:)-5a1pd","title":"static func pow(Complex<RealType>, Int) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/pow(_:_:)-5a1pd","title":"static func pow(Complex<RealType>, Int) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/root(_:_:)","title":"static func root(Complex<RealType>, Int) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/root(_:_:)","title":"static func root(Complex<RealType>, Int) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/sin(_:)","title":"static func sin(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/sin(_:)","title":"static func sin(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/sinh(_:)","title":"static func sinh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/sinh(_:)","title":"static func sinh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/sqrt(_:)","title":"static func sqrt(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/sqrt(_:)","title":"static func sqrt(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/tan(_:)","title":"static func tan(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/tan(_:)","title":"static func tan(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/tanh(_:)","title":"static func tanh(Complex<RealType>) -> Complex<RealType>","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/tanh(_:)","title":"static func tanh(Complex<RealType>) -> Complex<RealType>","type":"method"}],"path":"\/documentation\/complexmodule\/complex\/elementaryfunctions-implementations","title":"ElementaryFunctions Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/encode(to:)","title":"func encode(to: any Encoder) throws","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/encode(to:)","title":"func encode(to: any Encoder) throws","type":"method"}],"path":"\/documentation\/complexmodule\/complex\/encodable-implementations","title":"Encodable Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/==(_:_:)","title":"static func == (Complex<RealType>, Complex<RealType>) -> Bool","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/==(_:_:)","title":"static func == (Complex<RealType>, Complex<RealType>) -> Bool","type":"op"}],"path":"\/documentation\/complexmodule\/complex\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/init(integerliteral:)","title":"init(integerLiteral: Complex<RealType>.IntegerLiteralType)","type":"init"},{"path":"\/documentation\/complexmodule\/complex\/init(integerliteral:)","title":"init(integerLiteral: Complex<RealType>.IntegerLiteralType)","type":"init"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/integerliteraltype","title":"Complex.IntegerLiteralType","type":"typealias"},{"path":"\/documentation\/complexmodule\/complex\/integerliteraltype","title":"Complex.IntegerLiteralType","type":"typealias"}],"path":"\/documentation\/complexmodule\/complex\/expressiblebyintegerliteral-implementations","title":"ExpressibleByIntegerLiteral Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/complexmodule\/complex\/hashable-implementations","title":"Hashable Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/*(_:_:)","title":"static func * (Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/*(_:_:)","title":"static func * (Complex<RealType>, Complex<RealType>) -> Complex<RealType>","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/*=(_:_:)","title":"static func *= (inout Complex<RealType>, Complex<RealType>)","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/*=(_:_:)","title":"static func *= (inout Complex<RealType>, Complex<RealType>)","type":"op"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/init(exactly:)-282ck","title":"init?<Other>(exactly: Other)","type":"init"},{"path":"\/documentation\/complexmodule\/complex\/init(exactly:)-282ck","title":"init?<Other>(exactly: Other)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/magnitude","title":"var magnitude: RealType","type":"property"},{"path":"\/documentation\/complexmodule\/complex\/magnitude","title":"var magnitude: RealType","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/isapproximatelyequal(to:absolutetolerance:relativetolerance:)","title":"func isApproximatelyEqual(to: Self, absoluteTolerance: Self.Magnitude, relativeTolerance: Self.Magnitude) -> Bool","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/isapproximatelyequal(to:absolutetolerance:relativetolerance:)","title":"func isApproximatelyEqual(to: Self, absoluteTolerance: Self.Magnitude, relativeTolerance: Self.Magnitude) -> Bool","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/isapproximatelyequal(to:relativetolerance:norm:)","title":"func isApproximatelyEqual(to: Self, relativeTolerance: Self.Magnitude, norm: (Self) -> Self.Magnitude) -> Bool","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/isapproximatelyequal(to:relativetolerance:norm:)","title":"func isApproximatelyEqual(to: Self, relativeTolerance: Self.Magnitude, norm: (Self) -> Self.Magnitude) -> Bool","type":"method"}],"path":"\/documentation\/complexmodule\/complex\/numeric-implementations","title":"Numeric Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/-(_:)","title":"static func - (Self) -> Self","type":"op"},{"path":"\/documentation\/complexmodule\/complex\/-(_:)","title":"static func - (Self) -> Self","type":"op"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/complexmodule\/complex\/negate()","title":"func negate()","type":"method"},{"path":"\/documentation\/complexmodule\/complex\/negate()","title":"func negate()","type":"method"}],"path":"\/documentation\/complexmodule\/complex\/signednumeric-implementations","title":"SignedNumeric Implementations","type":"symbol"}],"path":"\/documentation\/complexmodule\/complex","title":"Complex","type":"struct"}],"path":"\/documentation\/complexmodule","title":"ComplexModule","type":"module"},{"children":[{"title":"Protocols","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"children":[{"children":[{"path":"\/documentation\/logger\/logger\/loglevel-489p","title":"var logLevel: LogLevel","type":"property"}],"title":"Logger Implementations","type":"groupMarker"}],"path":"\/documentation\/logger\/logger\/loglevel","title":"var logLevel: LogLevel","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"children":[{"children":[{"path":"\/documentation\/logger\/logger\/log(type:priority:message:)-606v2","title":"static func log(type: LogType, priority: LogPriority, message: String)","type":"method"},{"path":"\/documentation\/logger\/logger\/log(type:priority:message:)-9j67p","title":"func log(type: LogType, priority: LogPriority, message: String)","type":"method"}],"title":"Logger Implementations","type":"groupMarker"}],"path":"\/documentation\/logger\/logger\/log(type:priority:message:)-4wsqf","title":"func log(type: LogType, priority: LogPriority, message: String)","type":"method"},{"title":"Type Properties","type":"groupMarker"},{"children":[{"children":[{"path":"\/documentation\/logger\/logger\/oslogger-3h3sn","title":"static var osLogger: OSLog","type":"property"}],"title":"Logger Implementations","type":"groupMarker"}],"path":"\/documentation\/logger\/logger\/oslogger","title":"static var osLogger: OSLog","type":"property"},{"title":"Type Methods","type":"groupMarker"},{"children":[{"children":[{"path":"\/documentation\/logger\/logger\/log(type:priority:message:)-9j67p","title":"func log(type: LogType, priority: LogPriority, message: String)","type":"method"},{"path":"\/documentation\/logger\/logger\/log(type:priority:message:)-606v2","title":"static func log(type: LogType, priority: LogPriority, message: String)","type":"method"}],"title":"Logger Implementations","type":"groupMarker"}],"path":"\/documentation\/logger\/logger\/log(type:priority:message:)-1d6mz","title":"static func log(type: LogType, priority: LogPriority, message: String)","type":"method"}],"path":"\/documentation\/logger\/logger","title":"Logger","type":"protocol"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/logger\/loglevel\/high","title":"case high","type":"case"},{"path":"\/documentation\/logger\/loglevel\/low","title":"case low","type":"case"},{"path":"\/documentation\/logger\/loglevel\/medium","title":"case medium","type":"case"},{"path":"\/documentation\/logger\/loglevel\/none","title":"case none","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/logger\/loglevel\/init(rawvalue:)","title":"init?(rawValue: Int)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/logger\/loglevel\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/logger\/loglevel\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/logger\/loglevel\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/logger\/loglevel\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/logger\/loglevel\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/logger\/loglevel","title":"LogLevel","type":"enum"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/logger\/logpriority\/alwaysshow","title":"case alwaysShow","type":"case"},{"path":"\/documentation\/logger\/logpriority\/high","title":"case high","type":"case"},{"path":"\/documentation\/logger\/logpriority\/low","title":"case low","type":"case"},{"path":"\/documentation\/logger\/logpriority\/medium","title":"case medium","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/logger\/logpriority\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/logger\/logpriority\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/logger\/logpriority\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/logger\/logpriority\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/logger\/logpriority\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/logger\/logpriority\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/logger\/logpriority","title":"LogPriority","type":"enum"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/logger\/logtype\/error","title":"case error","type":"case"},{"path":"\/documentation\/logger\/logtype\/message","title":"case message","type":"case"},{"path":"\/documentation\/logger\/logtype\/success","title":"case success","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/logger\/logtype\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/logger\/logtype\/canshow(for:for:)","title":"func canShow(for: LogPriority, for: LogLevel) -> Bool","type":"method"},{"path":"\/documentation\/logger\/logtype\/oslogtype()","title":"func osLogType() -> OSLogType","type":"method"},{"path":"\/documentation\/logger\/logtype\/prefix()","title":"func prefix() -> String","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/logger\/logtype\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/logger\/logtype\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/logger\/logtype\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/logger\/logtype\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/logger\/logtype\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/logger\/logtype","title":"LogType","type":"enum"}],"path":"\/documentation\/logger","title":"Logger","type":"module"},{"children":[{"title":"Classes","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/adam\/init(_:device:learningrate:batchsize:b1:b2:eps:weightdecay:weightclip:gradientclip:)","title":"init(Trainable, device: Device, learningRate: Tensor.Scalar, batchSize: Int, b1: Tensor.Scalar, b2: Tensor.Scalar, eps: Tensor.Scalar, weightDecay: WeightDecay, weightClip: Tensor.Scalar?, gradientClip: Tensor.Scalar?)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/adam\/trainable","title":"var trainable: Trainable","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/adam\/reset()","title":"func reset()","type":"method"},{"path":"\/documentation\/neuron\/adam\/step()","title":"func step()","type":"method"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/adam\/weightdecay\/decay(_:)","title":"case decay(Tensor.Scalar)","type":"case"},{"path":"\/documentation\/neuron\/adam\/weightdecay\/none","title":"case none","type":"case"}],"path":"\/documentation\/neuron\/adam\/weightdecay","title":"Adam.WeightDecay","type":"enum"}],"path":"\/documentation\/neuron\/adam","title":"Adam","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/adamw\/init(_:device:learningrate:batchsize:b1:b2:eps:weightdecayvalue:weightclip:gradientclip:)","title":"init(Trainable, device: Device, learningRate: Tensor.Scalar, batchSize: Int, b1: Tensor.Scalar, b2: Tensor.Scalar, eps: Tensor.Scalar, weightDecayValue: Tensor.Scalar, weightClip: Tensor.Scalar?, gradientClip: Tensor.Scalar?)","type":"init"}],"path":"\/documentation\/neuron\/adamw","title":"AdamW","type":"class"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/atomicstorage\/clear()","title":"func clear()","type":"method"},{"path":"\/documentation\/neuron\/atomicstorage\/store(_:at:)","title":"func store(T?, at: Key)","type":"method"},{"path":"\/documentation\/neuron\/atomicstorage\/sync(_:)","title":"func sync(T)","type":"method"},{"path":"\/documentation\/neuron\/atomicstorage\/value(at:)","title":"func value(at: Key) -> T?","type":"method"},{"title":"Subscripts","type":"groupMarker"},{"path":"\/documentation\/neuron\/atomicstorage\/subscript(_:)","title":"subscript(Key) -> T?","type":"subscript"}],"path":"\/documentation\/neuron\/atomicstorage","title":"AtomicStorage","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/avgpool\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/avgpool\/init(inputsize:kernelsize:)","title":"init(inputSize: TensorSize?, kernelSize: (rows: Int, columns: Int))","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/avgpool\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/avgpool\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/avgpool\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/avgpool\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/avgpool","title":"AvgPool","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/baseactivationlayer\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/baseactivationlayer\/init(inputsize:type:encodingtype:)","title":"init(inputSize: TensorSize?, type: Activation, encodingType: EncodingType)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/baseactivationlayer\/details","title":"var details: String","type":"property"},{"path":"\/documentation\/neuron\/baseactivationlayer\/type","title":"let type: Activation","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/baseactivationlayer\/exportweights()","title":"func exportWeights() throws -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/baseactivationlayer\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/baseactivationlayer\/importweights(_:)","title":"func importWeights([Tensor]) throws","type":"method"}],"path":"\/documentation\/neuron\/baseactivationlayer","title":"BaseActivationLayer","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/init(filtercount:inputsize:strides:padding:filtersize:initializer:biasenabled:encodingtype:)","title":"init(filterCount: Int, inputSize: TensorSize?, strides: (rows: Int, columns: Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), initializer: InitializerType, biasEnabled: Bool, encodingType: EncodingType)","type":"init"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/details","title":"var details: String","type":"property"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/filtercount","title":"var filterCount: Int","type":"property"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/filtersize","title":"var filterSize: (rows: Int, columns: Int)","type":"property"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/filters","title":"var filters: [Tensor]","type":"property"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/padding","title":"var padding: NumSwift.ConvPadding","type":"property"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/strides","title":"var strides: (rows: Int, columns: Int)","type":"property"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/weights","title":"var weights: Tensor","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/exportweights()","title":"func exportWeights() throws -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/importweights(_:)","title":"func importWeights([Tensor]) throws","type":"method"},{"path":"\/documentation\/neuron\/baseconvolutionallayer\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/baseconvolutionallayer","title":"BaseConvolutionalLayer","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/basedecayfunction\/init(learningrate:decayrate:decaysteps:staircase:)","title":"init(learningRate: Tensor.Scalar, decayRate: Tensor.Scalar, decaySteps: Tensor.Scalar, staircase: Bool)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/basedecayfunction\/decayedlearningrate","title":"var decayedLearningRate: Tensor.Scalar","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/basedecayfunction\/reset()","title":"func reset()","type":"method"},{"path":"\/documentation\/neuron\/basedecayfunction\/step()","title":"func step()","type":"method"}],"path":"\/documentation\/neuron\/basedecayfunction","title":"BaseDecayFunction","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/baselayer\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/baselayer\/init(inputsize:initializer:biasenabled:encodingtype:)","title":"init(inputSize: TensorSize?, initializer: InitializerType, biasEnabled: Bool, encodingType: EncodingType)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/baselayer\/batchsize","title":"var batchSize: Int","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/biasenabled","title":"var biasEnabled: Bool","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/biases","title":"var biases: Tensor","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/details","title":"var details: String","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/device","title":"var device: Device","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/encodingtype","title":"var encodingType: EncodingType","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/initializer","title":"var initializer: Initializer","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/inputsize","title":"var inputSize: TensorSize","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/istraining","title":"var isTraining: Bool","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/outputsize","title":"var outputSize: TensorSize","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/trainable","title":"var trainable: Bool","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/usesoptimizer","title":"var usesOptimizer: Bool","type":"property"},{"path":"\/documentation\/neuron\/baselayer\/weights","title":"var weights: Tensor","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/baselayer\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/baselayer\/callasfunction(_:context:)","title":"func callAsFunction(Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/baselayer\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/baselayer\/exportweights()","title":"func exportWeights() throws -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/baselayer\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/baselayer\/forward(tensorbatch:context:)","title":"func forward(tensorBatch: TensorBatch, context: NetworkContext) -> TensorBatch","type":"method"},{"path":"\/documentation\/neuron\/baselayer\/importweights(_:)","title":"func importWeights([Tensor]) throws","type":"method"},{"path":"\/documentation\/neuron\/baselayer\/onbatchsizeset()","title":"func onBatchSizeSet()","type":"method"},{"path":"\/documentation\/neuron\/baselayer\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/baselayer\/extraencodables","title":"var extraEncodables: [String : Codable]?","type":"property"}],"path":"\/documentation\/neuron\/baselayer\/layer-implementations","title":"Layer Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/baselayer","title":"BaseLayer","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/baseoptimizer\/init(trainable:learningrate:batchsize:metricsreporter:weightclip:gradientclip:)","title":"init(trainable: Trainable, learningRate: Tensor.Scalar, batchSize: Int, metricsReporter: MetricsReporter?, weightClip: Tensor.Scalar?, gradientClip: Tensor.Scalar?)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/baseoptimizer\/batchsize","title":"var batchSize: Int","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/decayfunction","title":"var decayFunction: DecayFunction?","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/device","title":"var device: Device","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/gradientaccumulator","title":"var gradientAccumulator: GradientAccumulator","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/gradientclip","title":"var gradientClip: Tensor.Scalar?","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/istraining","title":"var isTraining: Bool","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/learningrate","title":"var learningRate: Tensor.Scalar","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/metricsreporter","title":"var metricsReporter: MetricsReporter?","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/passthroughgradientcalculation","title":"var passthroughGradientCalculation: Bool","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/trainable","title":"var trainable: Trainable","type":"property"},{"path":"\/documentation\/neuron\/baseoptimizer\/weightclip","title":"var weightClip: Tensor.Scalar?","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/baseoptimizer\/apply(_:)","title":"func apply(Tensor.Gradient)","type":"method"},{"path":"\/documentation\/neuron\/baseoptimizer\/callasfunction(_:)","title":"func callAsFunction([Tensor]) -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/baseoptimizer\/fit(_:labels:wrt:lossfunction:validation:requiresgradients:)","title":"func fit(TensorBatch, labels: TensorBatch, wrt: TensorBatch?, lossFunction: LossFunction, validation: Bool, requiresGradients: Bool) -> Output","type":"method"},{"path":"\/documentation\/neuron\/baseoptimizer\/predict(_:)","title":"func predict([Tensor]) -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/baseoptimizer\/reset()","title":"func reset()","type":"method"},{"path":"\/documentation\/neuron\/baseoptimizer\/step()","title":"func step()","type":"method"},{"path":"\/documentation\/neuron\/baseoptimizer\/zerogradients()","title":"func zeroGradients()","type":"method"}],"path":"\/documentation\/neuron\/baseoptimizer","title":"BaseOptimizer","type":"class"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/basethreadbatchinglayer\/istraining","title":"var isTraining: Bool","type":"property"},{"path":"\/documentation\/neuron\/basethreadbatchinglayer\/shouldperformbatching","title":"var shouldPerformBatching: Bool","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/basethreadbatchinglayer\/apply(gradients:learningrate:)","title":"func apply(gradients: (weights: Tensor, biases: Tensor), learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/basethreadbatchinglayer\/forward(tensorbatch:context:)","title":"func forward(tensorBatch: TensorBatch, context: NetworkContext) -> TensorBatch","type":"method"},{"path":"\/documentation\/neuron\/basethreadbatchinglayer\/performthreadbatchingforwardpass(tensor:context:)","title":"func performThreadBatchingForwardPass(tensor: Tensor, context: NetworkContext)","type":"method"}],"path":"\/documentation\/neuron\/basethreadbatchinglayer","title":"BaseThreadBatchingLayer","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/batchnormalize\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/batchnormalize\/init(gamma:beta:momentum:movingmean:movingvariance:inputsize:)","title":"init(gamma: [Tensor.Scalar], beta: [Tensor.Scalar], momentum: Tensor.Scalar, movingMean: Tensor, movingVariance: Tensor, inputSize: TensorSize?)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/batchnormalize\/beta","title":"var beta: [Tensor.Scalar]","type":"property"},{"path":"\/documentation\/neuron\/batchnormalize\/gamma","title":"var gamma: [Tensor.Scalar]","type":"property"},{"path":"\/documentation\/neuron\/batchnormalize\/momentum","title":"let momentum: Tensor.Scalar","type":"property"},{"path":"\/documentation\/neuron\/batchnormalize\/movingmean","title":"var movingMean: Tensor","type":"property"},{"path":"\/documentation\/neuron\/batchnormalize\/movingvariance","title":"var movingVariance: Tensor","type":"property"},{"path":"\/documentation\/neuron\/batchnormalize\/shouldperformbatching","title":"var shouldPerformBatching: Bool","type":"property"},{"path":"\/documentation\/neuron\/batchnormalize\/weights","title":"var weights: Tensor","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/batchnormalize\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/batchnormalize\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/batchnormalize\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/batchnormalize\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"},{"path":"\/documentation\/neuron\/batchnormalize\/performthreadbatchingforwardpass(tensor:context:)","title":"func performThreadBatchingForwardPass(tensor: Tensor, context: NetworkContext)","type":"method"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/beta","title":"case beta","type":"case"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/gamma","title":"case gamma","type":"case"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/inputsize","title":"case inputSize","type":"case"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/momentum","title":"case momentum","type":"case"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/movingmean","title":"case movingMean","type":"case"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/movingvariance","title":"case movingVariance","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/init(intvalue:)","title":"init?(intValue: Int)","type":"init"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/init(stringvalue:)","title":"init?(stringValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/debugdescription","title":"var debugDescription: String","type":"property"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/codingkey-implementations","title":"CodingKey Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/batchnormalize\/codingkeys\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/batchnormalize\/codingkeys","title":"BatchNormalize.CodingKeys","type":"enum"}],"path":"\/documentation\/neuron\/batchnormalize","title":"BatchNormalize","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/classifier\/init(optimizer:epochs:batchsize:accuracythreshold:killonaccuracy:log:lossfunction:)","title":"init(optimizer: Optimizer, epochs: Int, batchSize: Int, accuracyThreshold: AccuracyThreshold, killOnAccuracy: Bool, log: Bool, lossFunction: LossFunction)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/classifier\/onaccuracyreached","title":"var onAccuracyReached: (() -> ())?","type":"property"},{"path":"\/documentation\/neuron\/classifier\/onepochcompleted","title":"var onEpochCompleted: (() -> ())?","type":"property"},{"path":"\/documentation\/neuron\/classifier\/optimizer","title":"var optimizer: Optimizer","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/classifier\/export(overrite:compress:)","title":"func export(overrite: Bool, compress: Bool) -> URL?","type":"method"},{"path":"\/documentation\/neuron\/classifier\/feed(_:)","title":"func feed([Tensor]) -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/classifier\/fit(_:_:)","title":"func fit([DatasetModel], [DatasetModel])","type":"method"}],"path":"\/documentation\/neuron\/classifier","title":"Classifier","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/conv2d\/init(filtercount:inputsize:strides:padding:filtersize:initializer:biasenabled:encodingtype:)","title":"init(filterCount: Int, inputSize: TensorSize?, strides: (rows: Int, columns: Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), initializer: InitializerType, biasEnabled: Bool, encodingType: EncodingType)","type":"init"},{"path":"\/documentation\/neuron\/conv2d\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/conv2d\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/conv2d\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/conv2d\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/conv2d\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/conv2d","title":"Conv2d","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/dense\/init(_:inputs:initializer:biasenabled:)","title":"init(Int, inputs: Int?, initializer: InitializerType, biasEnabled: Bool)","type":"init"},{"path":"\/documentation\/neuron\/dense\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/dense\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/dense\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/dense\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/dense\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/dense","title":"Dense","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/dropout\/init(_:inputsize:)","title":"init(Tensor.Scalar, inputSize: TensorSize?)","type":"init"},{"path":"\/documentation\/neuron\/dropout\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/dropout\/details","title":"var details: String","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/dropout\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/dropout\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/dropout\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/dropout\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/dropout","title":"Dropout","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/embedding\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/embedding\/init(inputunits:vocabsize:batchlength:initializer:trainable:)","title":"init(inputUnits: Int, vocabSize: Int, batchLength: Int, initializer: InitializerType, trainable: Bool)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/embedding\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/embedding\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/embedding\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"}],"path":"\/documentation\/neuron\/embedding","title":"Embedding","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/exponentialdecay\/init(learningrate:decayrate:decaysteps:staircase:)","title":"init(learningRate: Tensor.Scalar, decayRate: Tensor.Scalar, decaySteps: Tensor.Scalar, staircase: Bool)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/exponentialdecay\/step()","title":"func step()","type":"method"}],"path":"\/documentation\/neuron\/exponentialdecay","title":"ExponentialDecay","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/flatten\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/flatten\/init(inputsize:)","title":"init(inputSize: TensorSize?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/flatten\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/flatten\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/flatten\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/flatten","title":"Flatten","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/gan\/init(generator:discriminator:epochs:batchsize:discriminatorsteps:generatorsteps:discriminatornoisefactor:validationfrequency:)","title":"init(generator: Optimizer, discriminator: Optimizer, epochs: Int, batchSize: Int, discriminatorSteps: Int, generatorSteps: Int, discriminatorNoiseFactor: Tensor.Scalar?, validationFrequency: Int)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/gan\/discriminator","title":"var discriminator: Optimizer","type":"property"},{"path":"\/documentation\/neuron\/gan\/epochs","title":"var epochs: Int","type":"property"},{"path":"\/documentation\/neuron\/gan\/fakelabel","title":"var fakeLabel: Tensor.Scalar","type":"property"},{"path":"\/documentation\/neuron\/gan\/generator","title":"var generator: Optimizer","type":"property"},{"path":"\/documentation\/neuron\/gan\/lossfunction","title":"var lossFunction: LossFunction","type":"property"},{"path":"\/documentation\/neuron\/gan\/noise","title":"var noise: () -> Tensor","type":"property"},{"path":"\/documentation\/neuron\/gan\/oncompleted","title":"var onCompleted: (() -> ())?","type":"property"},{"path":"\/documentation\/neuron\/gan\/onepochcompleted","title":"var onEpochCompleted: ((_ epoch: Int) -> ())?","type":"property"},{"path":"\/documentation\/neuron\/gan\/reallabel","title":"var realLabel: Tensor.Scalar","type":"property"},{"path":"\/documentation\/neuron\/gan\/validategenerator","title":"var validateGenerator: ((_ output: Tensor) -> ())?","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/gan\/discriminate(_:)","title":"func discriminate([Tensor]) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/gan\/export(overrite:compress:)","title":"func export(overrite: Bool, compress: Bool) -> (discriminator: URL?, generator: URL?)","type":"method"},{"path":"\/documentation\/neuron\/gan\/fit(_:_:)","title":"func fit([DatasetModel], [DatasetModel])","type":"method"},{"path":"\/documentation\/neuron\/gan\/generate()","title":"func generate() -> Tensor","type":"method"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/gan\/trainingtype\/fake","title":"case fake","type":"case"},{"path":"\/documentation\/neuron\/gan\/trainingtype\/real","title":"case real","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/gan\/trainingtype\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/gan\/trainingtype\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/gan\/trainingtype\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/gan\/trainingtype\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/gan\/trainingtype\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/gan\/trainingtype\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/gan\/trainingtype","title":"GAN.TrainingType","type":"enum"}],"path":"\/documentation\/neuron\/gan","title":"GAN","type":"class"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/gpu\/qospriority","title":"var qosPriority: DispatchQoS.QoSClass","type":"property"},{"path":"\/documentation\/neuron\/gpu\/type","title":"var type: DeviceType","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/gpu\/activate(_:_:)","title":"func activate(Tensor, Activation) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/gpu\/conv2d(signal:filter:strides:padding:filtersize:inputsize:outputsize:)","title":"func conv2d(signal: Tensor.Value, filter: Tensor.Value, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), outputSize: (rows: Int, columns: Int)?) -> Tensor.Value","type":"method"},{"path":"\/documentation\/neuron\/gpu\/derivate(_:_:)","title":"func derivate(Tensor, Activation) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/gpu\/matmul(_:_:)","title":"func matmul(Tensor, Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/gpu\/transconv2d(signal:filter:strides:padding:filtersize:inputsize:outputsize:)","title":"func transConv2d(signal: Tensor.Value, filter: Tensor.Value, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), outputSize: (rows: Int, columns: Int)?) -> Tensor.Value","type":"method"}],"path":"\/documentation\/neuron\/gpu","title":"GPU","type":"class"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/gpumanager\/activate(_:_:derivate:)","title":"func activate([Tensor.Scalar], Activation, derivate: Bool) -> [Tensor.Scalar]","type":"method"},{"title":"Type Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/gpumanager\/shared","title":"static let shared: GPUManager","type":"property"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/gpumanager\/metalfunction\/activation","title":"case activation","type":"case"},{"path":"\/documentation\/neuron\/gpumanager\/metalfunction\/derivate","title":"case derivate","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/gpumanager\/metalfunction\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/gpumanager\/metalfunction\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/gpumanager\/metalfunction\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/gpumanager\/metalfunction\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/gpumanager\/metalfunction\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/gpumanager\/metalfunction\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/gpumanager\/metalfunction","title":"GPUManager.MetalFunction","type":"enum"}],"path":"\/documentation\/neuron\/gpumanager","title":"GPUManager","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/gaussian\/init(std:mean:)","title":"init(std: Double, mean: Double)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/gaussian\/gaussrand","title":"var gaussRand: Double","type":"property"}],"path":"\/documentation\/neuron\/gaussian","title":"Gaussian","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/gelu\/init()","title":"init()","type":"init"},{"path":"\/documentation\/neuron\/gelu\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/gelu\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/gelu\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/gelu","title":"GeLu","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/globalavgpool\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/globalavgpool\/init(inputsize:)","title":"init(inputSize: TensorSize)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/globalavgpool\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/globalavgpool\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/globalavgpool\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/globalavgpool","title":"GlobalAvgPool","type":"class"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/gradientaccumulator\/average","title":"var average: Bool","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/gradientaccumulator\/accumulate(clearatend:)","title":"func accumulate(clearAtEnd: Bool) -> Tensor.Gradient","type":"method"},{"path":"\/documentation\/neuron\/gradientaccumulator\/clear()","title":"func clear()","type":"method"},{"path":"\/documentation\/neuron\/gradientaccumulator\/insert(_:)","title":"func insert(Tensor.Gradient)","type":"method"},{"path":"\/documentation\/neuron\/gradientaccumulator\/insert(input:weights:biases:)","title":"func insert(input: Tensor, weights: [Tensor], biases: [Tensor])","type":"method"}],"path":"\/documentation\/neuron\/gradientaccumulator","title":"GradientAccumulator","type":"class"},{"children":[{"title":"Classes","type":"groupMarker"},{"path":"\/documentation\/neuron\/lstm\/cache","title":"LSTM.Cache","type":"class"},{"path":"\/documentation\/neuron\/lstm\/lstmactivations","title":"LSTM.LSTMActivations","type":"class"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/lstm\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/lstm\/init(inputunits:batchlength:returnsequence:biasenabled:initializer:hiddenunits:vocabsize:)","title":"init(inputUnits: Int, batchLength: Int, returnSequence: Bool, biasEnabled: Bool, initializer: InitializerType, hiddenUnits: Int, vocabSize: Int)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/lstm\/biases","title":"var biases: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/forgetgatebiases","title":"var forgetGateBiases: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/forgetgateweights","title":"var forgetGateWeights: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/gategatebiases","title":"var gateGateBiases: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/gategateweights","title":"var gateGateWeights: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/hiddenoutputbiases","title":"var hiddenOutputBiases: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/hiddenoutputweights","title":"var hiddenOutputWeights: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/inputgatebiases","title":"var inputGateBiases: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/inputgateweights","title":"var inputGateWeights: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/outputgatebiases","title":"var outputGateBiases: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/outputgateweights","title":"var outputGateWeights: Tensor","type":"property"},{"path":"\/documentation\/neuron\/lstm\/weights","title":"var weights: Tensor","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/lstm\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/lstm\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/lstm\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/lstm\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/lstm","title":"LSTM","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodel\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodel\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/layer","title":"case layer","type":"case"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/type","title":"case type","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/init(intvalue:)","title":"init?(intValue: Int)","type":"init"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/init(stringvalue:)","title":"init?(stringValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/debugdescription","title":"var debugDescription: String","type":"property"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/neuron\/layermodel\/codingkeys\/codingkey-implementations","title":"CodingKey Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/layermodel\/codingkeys\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodel\/codingkeys\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/layermodel\/codingkeys\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/layermodel\/codingkeys","title":"LayerModel.CodingKeys","type":"enum"}],"path":"\/documentation\/neuron\/layermodel","title":"LayerModel","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/layernormalize\/init(epsilon:gamma:beta:inputsize:)","title":"init(epsilon: Tensor.Scalar, gamma: Tensor, beta: Tensor, inputSize: TensorSize?)","type":"init"},{"path":"\/documentation\/neuron\/layernormalize\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layernormalize\/beta","title":"var beta: Tensor","type":"property"},{"path":"\/documentation\/neuron\/layernormalize\/gamma","title":"var gamma: Tensor","type":"property"},{"path":"\/documentation\/neuron\/layernormalize\/weights","title":"var weights: Tensor","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/layernormalize\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/layernormalize\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/layernormalize\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/layernormalize\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/beta","title":"case beta","type":"case"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/epsilon","title":"case epsilon","type":"case"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/gamma","title":"case gamma","type":"case"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/inputsize","title":"case inputSize","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/init(intvalue:)","title":"init?(intValue: Int)","type":"init"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/init(stringvalue:)","title":"init?(stringValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/debugdescription","title":"var debugDescription: String","type":"property"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/codingkey-implementations","title":"CodingKey Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/layernormalize\/codingkeys\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/layernormalize\/codingkeys","title":"LayerNormalize.CodingKeys","type":"enum"}],"path":"\/documentation\/neuron\/layernormalize","title":"LayerNormalize","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/leakyrelu\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/leakyrelu\/init(limit:)","title":"init(limit: Tensor.Scalar)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/leakyrelu\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/leakyrelu\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/leakyrelu","title":"LeakyReLu","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/maxpool\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/maxpool\/init(inputsize:)","title":"init(inputSize: TensorSize?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/maxpool\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/maxpool\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/maxpool\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/maxpool\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/maxpool","title":"MaxPool","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/metricsreporter\/init(frequency:metricstogather:)","title":"init(frequency: Int, metricsToGather: Set<Metric>)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/metricsreporter\/lock","title":"var lock: NSLock","type":"property"},{"path":"\/documentation\/neuron\/metricsreporter\/metrics","title":"var metrics: [Metric : Tensor.Scalar]","type":"property"},{"path":"\/documentation\/neuron\/metricsreporter\/metricstogather","title":"var metricsToGather: Set<Metric>","type":"property"},{"path":"\/documentation\/neuron\/metricsreporter\/receive","title":"var receive: ((_ metrics: [Metric : Tensor.Scalar]) -> ())?","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/metricsreporter\/endtimer(metric:)","title":"func endTimer(metric: Metric)","type":"method"},{"path":"\/documentation\/neuron\/metricsreporter\/starttimer(metric:)","title":"func startTimer(metric: Metric)","type":"method"},{"title":"Subscripts","type":"groupMarker"},{"path":"\/documentation\/neuron\/metricsreporter\/subscript(dynamicmember:)","title":"subscript(dynamicMember _: String) -> Tensor.Scalar?","type":"subscript"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/metricsreporter\/addmetric(value:key:)","title":"func addMetric(value: Tensor.Scalar, key: Metric)","type":"method"}],"path":"\/documentation\/neuron\/metricsreporter\/metriclogger-implementations","title":"MetricLogger Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/metricsreporter","title":"MetricsReporter","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/rmsprop\/init(_:device:learningrate:batchsize:b:eps:weightclip:gradientclip:)","title":"init(Trainable, device: Device, learningRate: Tensor.Scalar, batchSize: Int, b: Tensor.Scalar, eps: Tensor.Scalar, weightClip: Tensor.Scalar?, gradientClip: Tensor.Scalar?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/rmsprop\/reset()","title":"func reset()","type":"method"},{"path":"\/documentation\/neuron\/rmsprop\/step()","title":"func step()","type":"method"}],"path":"\/documentation\/neuron\/rmsprop","title":"RMSProp","type":"class"},{"children":[{"title":"Structures","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/rnn\/classifierparameters\/init(batchsize:epochs:accuracythreshold:killonaccuracy:lossfunction:)","title":"init(batchSize: Int, epochs: Int, accuracyThreshold: AccuracyThreshold, killOnAccuracy: Bool, lossFunction: LossFunction)","type":"init"}],"path":"\/documentation\/neuron\/rnn\/classifierparameters","title":"RNN.ClassifierParameters","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/rnn\/optimizerparameters\/init(learningrate:b1:b2:eps:weightdecay:metricsreporter:)","title":"init(learningRate: Tensor.Scalar, b1: Tensor.Scalar, b2: Tensor.Scalar, eps: Tensor.Scalar, weightDecay: Adam.WeightDecay, metricsReporter: MetricsReporter?)","type":"init"}],"path":"\/documentation\/neuron\/rnn\/optimizerparameters","title":"RNN.OptimizerParameters","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/rnn\/rnnlstmparameters\/init(hiddenunits:inputunits:embeddinginitializer:lstminitializer:)","title":"init(hiddenUnits: Int, inputUnits: Int, embeddingInitializer: InitializerType, lstmInitializer: InitializerType)","type":"init"}],"path":"\/documentation\/neuron\/rnn\/rnnlstmparameters","title":"RNN.RNNLSTMParameters","type":"struct"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/rnn\/init(device:returnsequence:dataset:classifierparameters:optimizerparameters:lstmparameters:extralayers:)","title":"init(device: Device, returnSequence: Bool, dataset: Dataset, classifierParameters: ClassifierParameters, optimizerParameters: OptimizerParameters, lstmParameters: RNNLSTMParameters, extraLayers: () -> [Layer])","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/rnn\/importfrom(url:)","title":"func importFrom(url: URL?) async","type":"method"},{"path":"\/documentation\/neuron\/rnn\/predict(starting:count:maxwordlength:randomizeselection:endingmark:)","title":"func predict(starting: String?, count: Int, maxWordLength: Int, randomizeSelection: Bool, endingMark: String) -> [String]","type":"method"},{"path":"\/documentation\/neuron\/rnn\/readyup()","title":"func readyUp() async","type":"method"},{"path":"\/documentation\/neuron\/rnn\/train()","title":"func train() async","type":"method"}],"path":"\/documentation\/neuron\/rnn","title":"RNN","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/relu\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/relu\/init(inputsize:)","title":"init(inputSize: TensorSize?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/relu\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/relu\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/relu","title":"ReLu","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/resnet\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/resnet\/init(inputsize:initializer:filtercount:stride:)","title":"init(inputSize: TensorSize?, initializer: InitializerType, filterCount: Int, stride: Int)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/resnet\/istraining","title":"var isTraining: Bool","type":"property"},{"path":"\/documentation\/neuron\/resnet\/weights","title":"var weights: Tensor","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/resnet\/apply(gradients:learningrate:)","title":"func apply(gradients: (weights: Tensor, biases: Tensor), learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/resnet\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/resnet\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/resnet\/forward(tensorbatch:context:)","title":"func forward(tensorBatch: TensorBatch, context: NetworkContext) -> TensorBatch","type":"method"},{"path":"\/documentation\/neuron\/resnet\/onbatchsizeset()","title":"func onBatchSizeSet()","type":"method"},{"path":"\/documentation\/neuron\/resnet\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/resnet","title":"ResNet","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/reshape\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/reshape\/init(to:inputsize:)","title":"init(to: TensorSize, inputSize: TensorSize?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/reshape\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/reshape\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/reshape\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/reshape","title":"Reshape","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/sgd\/init(_:device:learningrate:batchsize:momentum:weightclip:gradientclip:)","title":"init(Trainable, device: Device, learningRate: Tensor.Scalar, batchSize: Int, momentum: Tensor.Scalar, weightClip: Tensor.Scalar?, gradientClip: Tensor.Scalar?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/sgd\/reset()","title":"func reset()","type":"method"},{"path":"\/documentation\/neuron\/sgd\/step()","title":"func step()","type":"method"}],"path":"\/documentation\/neuron\/sgd","title":"SGD","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/selu\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/selu\/init(inputsize:)","title":"init(inputSize: TensorSize?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/selu\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/selu\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/selu","title":"SeLu","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/sequential\/init(_:)-7uonb","title":"init(() -> [Layer])","type":"init"},{"path":"\/documentation\/neuron\/sequential\/init(_:)-rsry","title":"init(Layer...)","type":"init"},{"path":"\/documentation\/neuron\/sequential\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/sequential\/batchsize","title":"var batchSize: Int","type":"property"},{"path":"\/documentation\/neuron\/sequential\/device","title":"var device: Device","type":"property"},{"path":"\/documentation\/neuron\/sequential\/iscompiled","title":"var isCompiled: Bool","type":"property"},{"path":"\/documentation\/neuron\/sequential\/istraining","title":"var isTraining: Bool","type":"property"},{"path":"\/documentation\/neuron\/sequential\/layers","title":"var layers: [Layer]","type":"property"},{"path":"\/documentation\/neuron\/sequential\/loglevel","title":"var logLevel: LogLevel","type":"property"},{"path":"\/documentation\/neuron\/sequential\/name","title":"var name: String","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/sequential\/apply(gradients:learningrate:)","title":"func apply(gradients: Tensor.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/sequential\/callasfunction(_:context:)-37z9b","title":"func callAsFunction(TensorBatch, context: NetworkContext) -> TensorBatch","type":"method"},{"path":"\/documentation\/neuron\/sequential\/callasfunction(_:context:)-51fj7","title":"func callAsFunction(Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/sequential\/compile()","title":"func compile()","type":"method"},{"path":"\/documentation\/neuron\/sequential\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/sequential\/exportweights()","title":"func exportWeights() throws -> [[Tensor]]","type":"method"},{"path":"\/documentation\/neuron\/sequential\/importweights(_:)","title":"func importWeights([[Tensor]]) throws","type":"method"},{"path":"\/documentation\/neuron\/sequential\/predict(_:context:)","title":"func predict(Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/sequential\/predict(batch:context:)","title":"func predict(batch: TensorBatch, context: NetworkContext) -> TensorBatch","type":"method"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/sequential\/import(_:)","title":"static func `import`(URL) -> Self","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/sequential\/debugdescription","title":"var debugDescription: String","type":"property"}],"path":"\/documentation\/neuron\/sequential\/customdebugstringconvertible-implementations","title":"CustomDebugStringConvertible Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/sequential\/log(type:priority:message:)","title":"func log(type: LogType, priority: LogPriority, message: String)","type":"method"},{"title":"Type Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/sequential\/oslogger","title":"static var osLogger: OSLog","type":"property"}],"path":"\/documentation\/neuron\/sequential\/logger-implementations","title":"Logger Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/sequential\/export(name:overrite:compress:)","title":"func export(name: String?, overrite: Bool, compress: Bool) -> URL?","type":"method"}],"path":"\/documentation\/neuron\/sequential\/trainable-implementations","title":"Trainable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/sequential","title":"Sequential","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/sigmoid\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/sigmoid\/init(inputsize:)","title":"init(inputSize: TensorSize?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/sigmoid\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/sigmoid\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/sigmoid","title":"Sigmoid","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/softmax\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/softmax\/init(inputsize:)","title":"init(inputSize: TensorSize?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/softmax\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/softmax\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/softmax\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/softmax","title":"Softmax","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/swish\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/swish\/init(inputsize:)","title":"init(inputSize: TensorSize?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/swish\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/swish\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/swish","title":"Swish","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/synchronousoperationqueue\/init(name:)","title":"init(name: String?)","type":"init"}],"path":"\/documentation\/neuron\/synchronousoperationqueue","title":"SynchronousOperationQueue","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/tanh\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/tanh\/init(inputsize:)","title":"init(inputSize: TensorSize?)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/tanh\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/tanh\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/tanh","title":"Tanh","type":"class"},{"children":[{"title":"Structures","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/gradient\/*(_:_:)-2tvzd","title":"static func * (Tensor.Gradient, Tensor.Gradient) -> Tensor.Gradient","type":"op"},{"path":"\/documentation\/neuron\/tensor\/gradient\/*(_:_:)-6xja8","title":"static func * (Tensor.Gradient, Tensor.Scalar) -> Tensor.Gradient","type":"op"},{"path":"\/documentation\/neuron\/tensor\/gradient\/+(_:_:)-64i3b","title":"static func + (Tensor.Gradient, Tensor.Scalar) -> Tensor.Gradient","type":"op"},{"path":"\/documentation\/neuron\/tensor\/gradient\/+(_:_:)-9177a","title":"static func + (Tensor.Gradient, Tensor.Gradient) -> Tensor.Gradient","type":"op"},{"path":"\/documentation\/neuron\/tensor\/gradient\/-(_:_:)-45u7q","title":"static func - (Tensor.Gradient, Tensor.Scalar) -> Tensor.Gradient","type":"op"},{"path":"\/documentation\/neuron\/tensor\/gradient\/-(_:_:)-f57f","title":"static func - (Tensor.Gradient, Tensor.Gradient) -> Tensor.Gradient","type":"op"},{"path":"\/documentation\/neuron\/tensor\/gradient\/_(_:_:)-16adv","title":"static func \/ (Tensor.Gradient, Tensor.Scalar) -> Tensor.Gradient","type":"op"},{"path":"\/documentation\/neuron\/tensor\/gradient\/_(_:_:)-tmi4","title":"static func \/ (Tensor.Gradient, Tensor.Gradient) -> Tensor.Gradient","type":"op"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/gradient\/init(input:weights:biases:)","title":"init(input: [Tensor], weights: [Tensor], biases: [Tensor])","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/gradient\/gradientl2normclip(_:)","title":"func gradientL2NormClip(Tensor.Scalar) -> Tensor.Gradient","type":"method"},{"path":"\/documentation\/neuron\/tensor\/gradient\/l2nomalizeweightsandbiases()","title":"func l2NomalizeWeightsAndBiases()","type":"method"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/gradient\/applymultiple(lhs:rhs:block:)","title":"static func applyMultiple(lhs: Tensor.Gradient, rhs: Tensor.Gradient, block: (_ lhs: [Tensor], _ rhs: [Tensor]) -> [Tensor]) -> Tensor.Gradient","type":"method"},{"path":"\/documentation\/neuron\/tensor\/gradient\/applyscalar(lhs:rhs:block:)","title":"static func applyScalar(lhs: Tensor.Gradient, rhs: Tensor.Scalar, block: (_ lhs: [Tensor], _ rhs: Tensor.Scalar) -> [Tensor]) -> Tensor.Gradient","type":"method"}],"path":"\/documentation\/neuron\/tensor\/gradient","title":"Tensor.Gradient","type":"struct"},{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/*(_:_:)-2mfct","title":"static func * (Scalar, Tensor) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/*(_:_:)-5za8i","title":"static func * (Tensor, Scalar) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/*(_:_:)-o67k","title":"static func * (Tensor, Tensor) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/+(_:_:)-54a4i","title":"static func + (Tensor, Tensor) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/+(_:_:)-mb3b","title":"static func + (Tensor, Scalar) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/-(_:_:)-66xu0","title":"static func - (Tensor, Scalar) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/-(_:_:)-7sbig","title":"static func - (Scalar, Tensor) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/-(_:_:)-9gjhj","title":"static func - (Tensor, Tensor) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/==(_:_:)","title":"static func == (Tensor, Tensor) -> Bool","type":"op"},{"path":"\/documentation\/neuron\/tensor\/_(_:_:)-1vnuf","title":"static func \/ (Tensor, Scalar) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/_(_:_:)-5w44r","title":"static func \/ (Tensor, Tensor) -> Tensor","type":"op"},{"path":"\/documentation\/neuron\/tensor\/_(_:_:)-9jdje","title":"static func \/ (Scalar, Tensor) -> Tensor","type":"op"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/init()","title":"init()","type":"init"},{"path":"\/documentation\/neuron\/tensor\/init(_:context:)-26bbk","title":"init(Scalar?, context: TensorContext)","type":"init"},{"path":"\/documentation\/neuron\/tensor\/init(_:context:)-444gx","title":"init([[Scalar]], context: TensorContext)","type":"init"},{"path":"\/documentation\/neuron\/tensor\/init(_:context:)-8l3hb","title":"init([Scalar], context: TensorContext)","type":"init"},{"path":"\/documentation\/neuron\/tensor\/init(_:context:)-8mx99","title":"init(Data, context: TensorContext)","type":"init"},{"path":"\/documentation\/neuron\/tensor\/init(_:size:context:)","title":"init(Tensor.Value, size: TensorSize, context: TensorContext)","type":"init"},{"path":"\/documentation\/neuron\/tensor\/init(from:)","title":"init(from: any Decoder) throws","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/features","title":"var features: Int","type":"property"},{"path":"\/documentation\/neuron\/tensor\/id-swift.property","title":"var id: ID","type":"property"},{"path":"\/documentation\/neuron\/tensor\/input","title":"var input: [ID : Tensor]","type":"property"},{"path":"\/documentation\/neuron\/tensor\/isempty","title":"var isEmpty: Bool","type":"property"},{"path":"\/documentation\/neuron\/tensor\/label","title":"var label: String","type":"property"},{"path":"\/documentation\/neuron\/tensor\/shape","title":"var shape: [Int]","type":"property"},{"path":"\/documentation\/neuron\/tensor\/size","title":"var size: TensorSize","type":"property"},{"path":"\/documentation\/neuron\/tensor\/storage","title":"var storage: Tensor.Value","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/addalong(axis:value:)","title":"func addAlong(axis: Int, value: Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/apply(axis:_:)","title":"func apply(axis: Int, MathBlock) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/applyalong(axis:input:_:)","title":"func applyAlong(axis: Int, input: Tensor, MathAlongBlock) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/asscalar()","title":"func asScalar() -> Scalar","type":"method"},{"path":"\/documentation\/neuron\/tensor\/clip(_:)","title":"func clip(Scalar)","type":"method"},{"path":"\/documentation\/neuron\/tensor\/concat(_:axis:)","title":"func concat(Tensor, axis: Int) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/copy(keepcontext:)","title":"func copy(keepContext: Bool) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/depthslice(_:)","title":"func depthSlice(Int) -> Tensor.Value","type":"method"},{"path":"\/documentation\/neuron\/tensor\/depthslicetensor(_:)","title":"func depthSliceTensor(Int) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/detached()","title":"func detached() -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/dividealong(axis:value:)","title":"func divideAlong(axis: Int, value: Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/encode(to:)","title":"func encode(to: any Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/tensor\/flatindex(column:row:depth:)","title":"func flatIndex(column: Int, row: Int, depth: Int) -> Int","type":"method"},{"path":"\/documentation\/neuron\/tensor\/gradients(delta:wrt:)","title":"func gradients(delta: Tensor, wrt: Tensor?) -> Tensor.Gradient","type":"method"},{"path":"\/documentation\/neuron\/tensor\/isscalar()","title":"func isScalar() -> Bool","type":"method"},{"path":"\/documentation\/neuron\/tensor\/isvalueequal(to:)","title":"func isValueEqual(to: Tensor) -> Bool","type":"method"},{"path":"\/documentation\/neuron\/tensor\/isvalueequal(to:accuracy:)","title":"func isValueEqual(to: Tensor, accuracy: Tensor.Scalar) -> Bool","type":"method"},{"path":"\/documentation\/neuron\/tensor\/l2norm()","title":"func l2Norm() -> Scalar","type":"method"},{"path":"\/documentation\/neuron\/tensor\/l2normalize()","title":"func l2Normalize()","type":"method"},{"path":"\/documentation\/neuron\/tensor\/l2normalized()","title":"func l2Normalized() -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/map(_:)","title":"func map((Tensor.Scalar) -> Tensor.Scalar) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/matmul(_:)","title":"func matmul(Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/mean(axis:)","title":"func mean(axis: Int) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/multiply(axis:)","title":"func multiply(axis: Int) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/multiplyalong(axis:value:)","title":"func multiplyAlong(axis: Int, value: Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/norm(axis:)","title":"func norm(axis: Int) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/oneslike()","title":"func onesLike() -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/printgraph(wrt:deep:)","title":"func printGraph(wrt: Tensor?, deep: Bool)","type":"method"},{"path":"\/documentation\/neuron\/tensor\/setdepthslice(_:_:)","title":"func setDepthSlice(Int, Tensor.Value)","type":"method"},{"path":"\/documentation\/neuron\/tensor\/setgraph(_:breakcycles:)","title":"func setGraph(Tensor, breakCycles: Bool)","type":"method"},{"path":"\/documentation\/neuron\/tensor\/split(into:axis:)","title":"func split(into: Int, axis: Int) -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/tensor\/sqrt(adding:)","title":"func sqrt(adding: Tensor.Scalar) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/subtract(axis:)","title":"func subtract(axis: Int) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/subtractalong(axis:value:)","title":"func subtractAlong(axis: Int, value: Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/sum()","title":"func sum() -> Scalar","type":"method"},{"path":"\/documentation\/neuron\/tensor\/sum(axis:)","title":"func sum(axis: Int) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/sumofsquares(axis:)","title":"func sumOfSquares(axis: Int) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/testinf()","title":"func testInf()","type":"method"},{"path":"\/documentation\/neuron\/tensor\/testlarge(limit:)","title":"func testLarge(limit: Scalar)","type":"method"},{"path":"\/documentation\/neuron\/tensor\/testnan()","title":"func testNaN()","type":"method"},{"path":"\/documentation\/neuron\/tensor\/transposed()","title":"func transposed() -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/variance(axis:)","title":"func variance(axis: Int) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/zeroslike()","title":"func zerosLike() -> Tensor","type":"method"},{"title":"Subscripts","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/subscript(_:_:_:)-33ak5","title":"subscript(Int, Int, Int) -> Scalar","type":"subscript"},{"path":"\/documentation\/neuron\/tensor\/subscript(_:_:_:)-7ztbg","title":"subscript(some RangeExpression<Int>, some RangeExpression<Int>, some RangeExpression<Int>) -> Tensor","type":"subscript"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/data","title":"Tensor.Data","type":"typealias"},{"path":"\/documentation\/neuron\/tensor\/id-swift.typealias","title":"Tensor.ID","type":"typealias"},{"path":"\/documentation\/neuron\/tensor\/mathalongblock","title":"Tensor.MathAlongBlock","type":"typealias"},{"path":"\/documentation\/neuron\/tensor\/mathblock","title":"Tensor.MathBlock","type":"typealias"},{"path":"\/documentation\/neuron\/tensor\/scalar","title":"Tensor.Scalar","type":"typealias"},{"path":"\/documentation\/neuron\/tensor\/value","title":"Tensor.Value","type":"typealias"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/axistoapplyalong(selfsize:size:)","title":"static func axisToApplyAlong(selfSize: TensorSize, size: TensorSize) -> Int?","type":"method"},{"path":"\/documentation\/neuron\/tensor\/fillrandom(in:size:)","title":"static func fillRandom(in: ClosedRange<Tensor.Scalar>, size: TensorSize) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/tensor\/fillwith(value:size:)","title":"static func fillWith(value: Tensor.Scalar, size: TensorSize) -> Tensor","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/debugdescription","title":"var debugDescription: String","type":"property"}],"path":"\/documentation\/neuron\/tensor\/customdebugstringconvertible-implementations","title":"CustomDebugStringConvertible Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensor\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/tensor\/equatable-implementations","title":"Equatable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/tensor","title":"Tensor","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/transconv2d\/init(filtercount:inputsize:strides:padding:filtersize:initializer:biasenabled:encodingtype:)","title":"init(filterCount: Int, inputSize: TensorSize?, strides: (rows: Int, columns: Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), initializer: InitializerType, biasEnabled: Bool, encodingType: EncodingType)","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/transconv2d\/oninputsizeset()","title":"func onInputSizeSet()","type":"method"}],"path":"\/documentation\/neuron\/transconv2d","title":"TransConv2d","type":"class"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorizer\/init(startandendingencoding:)","title":"init(startAndEndingEncoding: Bool)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorizer\/end","title":"let end: Int","type":"property"},{"path":"\/documentation\/neuron\/vectorizer\/inversevector","title":"var inverseVector: InverseVector","type":"property"},{"path":"\/documentation\/neuron\/vectorizer\/start","title":"let start: Int","type":"property"},{"path":"\/documentation\/neuron\/vectorizer\/vector","title":"var vector: Vector","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorizer\/onehot(_:)","title":"func oneHot([T]) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/vectorizer\/unvectorize(_:)","title":"func unvectorize([Int]) -> [T]","type":"method"},{"path":"\/documentation\/neuron\/vectorizer\/unvectorizeonehot(_:)","title":"func unvectorizeOneHot(Tensor) -> [T]","type":"method"},{"path":"\/documentation\/neuron\/vectorizer\/vectorize(_:format:)","title":"func vectorize([T], format: VectorFormat) -> [Int]","type":"method"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorizer\/item","title":"Vectorizer.Item","type":"typealias"}],"path":"\/documentation\/neuron\/vectorizer","title":"Vectorizer","type":"class"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/wgan\/fakelabel","title":"var fakeLabel: Tensor.Scalar","type":"property"},{"path":"\/documentation\/neuron\/wgan\/lossfunction","title":"var lossFunction: LossFunction","type":"property"},{"path":"\/documentation\/neuron\/wgan\/reallabel","title":"var realLabel: Tensor.Scalar","type":"property"}],"path":"\/documentation\/neuron\/wgan","title":"WGAN","type":"class"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/wgangp\/fakelabel","title":"var fakeLabel: Tensor.Scalar","type":"property"},{"path":"\/documentation\/neuron\/wgangp\/lambda","title":"var lambda: Tensor.Scalar","type":"property"},{"path":"\/documentation\/neuron\/wgangp\/lossfunction","title":"var lossFunction: LossFunction","type":"property"},{"path":"\/documentation\/neuron\/wgangp\/reallabel","title":"var realLabel: Tensor.Scalar","type":"property"}],"path":"\/documentation\/neuron\/wgangp","title":"WGANGP","type":"class"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/welfordvariance\/iterations","title":"var iterations: Int","type":"property"},{"path":"\/documentation\/neuron\/welfordvariance\/m2s","title":"var m2s: [Tensor.Value]","type":"property"},{"path":"\/documentation\/neuron\/welfordvariance\/means","title":"var means: [Tensor.Value]","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/welfordvariance\/reset()","title":"func reset()","type":"method"},{"path":"\/documentation\/neuron\/welfordvariance\/setinputsize(_:)","title":"func setInputSize(TensorSize)","type":"method"},{"path":"\/documentation\/neuron\/welfordvariance\/update(_:)","title":"func update(Tensor)","type":"method"}],"path":"\/documentation\/neuron\/welfordvariance","title":"WelfordVariance","type":"class"},{"title":"Protocols","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/activationlayer\/type","title":"var type: Activation","type":"property"}],"path":"\/documentation\/neuron\/activationlayer","title":"ActivationLayer","type":"protocol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/convolutionallayer\/filtercount","title":"var filterCount: Int","type":"property"},{"path":"\/documentation\/neuron\/convolutionallayer\/filtersize","title":"var filterSize: (rows: Int, columns: Int)","type":"property"},{"path":"\/documentation\/neuron\/convolutionallayer\/filters","title":"var filters: [Tensor]","type":"property"},{"path":"\/documentation\/neuron\/convolutionallayer\/padding","title":"var padding: NumSwift.ConvPadding","type":"property"},{"path":"\/documentation\/neuron\/convolutionallayer\/strides","title":"var strides: (rows: Int, columns: Int)","type":"property"}],"path":"\/documentation\/neuron\/convolutionallayer","title":"ConvolutionalLayer","type":"protocol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/decayfunction\/decayedlearningrate","title":"var decayedLearningRate: Tensor.Scalar","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/decayfunction\/reset()","title":"func reset()","type":"method"},{"path":"\/documentation\/neuron\/decayfunction\/step()","title":"func step()","type":"method"}],"path":"\/documentation\/neuron\/decayfunction","title":"DecayFunction","type":"protocol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/device\/qospriority","title":"var qosPriority: DispatchQoS.QoSClass","type":"property"},{"path":"\/documentation\/neuron\/device\/type","title":"var type: DeviceType","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/device\/activate(_:_:)","title":"func activate(Tensor, Activation) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/device\/conv2d(signal:filter:strides:padding:filtersize:inputsize:outputsize:)","title":"func conv2d(signal: Tensor.Value, filter: Tensor.Value, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), outputSize: (rows: Int, columns: Int)?) -> Tensor.Value","type":"method"},{"path":"\/documentation\/neuron\/device\/derivate(_:_:)","title":"func derivate(Tensor, Activation) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/device\/matmul(_:_:)","title":"func matmul(Tensor, Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/device\/transconv2d(signal:filter:strides:padding:filtersize:inputsize:outputsize:)","title":"func transConv2d(signal: Tensor.Value, filter: Tensor.Value, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), outputSize: (rows: Int, columns: Int)?) -> Tensor.Value","type":"method"}],"path":"\/documentation\/neuron\/device","title":"Device","type":"protocol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layer\/batchsize","title":"var batchSize: Int","type":"property"},{"path":"\/documentation\/neuron\/layer\/biasenabled","title":"var biasEnabled: Bool","type":"property"},{"path":"\/documentation\/neuron\/layer\/biases","title":"var biases: Tensor","type":"property"},{"path":"\/documentation\/neuron\/layer\/details","title":"var details: String","type":"property"},{"path":"\/documentation\/neuron\/layer\/device","title":"var device: Device","type":"property"},{"path":"\/documentation\/neuron\/layer\/encodingtype","title":"var encodingType: EncodingType","type":"property"},{"children":[{"children":[{"path":"\/documentation\/neuron\/layer\/extraencodables-f7zv","title":"var extraEncodables: [String : Codable]?","type":"property"}],"title":"Layer Implementations","type":"groupMarker"}],"path":"\/documentation\/neuron\/layer\/extraencodables","title":"var extraEncodables: [String : Codable]?","type":"property"},{"path":"\/documentation\/neuron\/layer\/initializer","title":"var initializer: Initializer","type":"property"},{"path":"\/documentation\/neuron\/layer\/inputsize","title":"var inputSize: TensorSize","type":"property"},{"path":"\/documentation\/neuron\/layer\/istraining","title":"var isTraining: Bool","type":"property"},{"path":"\/documentation\/neuron\/layer\/outputsize","title":"var outputSize: TensorSize","type":"property"},{"path":"\/documentation\/neuron\/layer\/trainable","title":"var trainable: Bool","type":"property"},{"path":"\/documentation\/neuron\/layer\/usesoptimizer","title":"var usesOptimizer: Bool","type":"property"},{"path":"\/documentation\/neuron\/layer\/weights","title":"var weights: Tensor","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/layer\/apply(gradients:learningrate:)","title":"func apply(gradients: Optimizer.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/layer\/exportweights()","title":"func exportWeights() throws -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/layer\/forward(tensor:context:)","title":"func forward(tensor: Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/layer\/forward(tensorbatch:context:)","title":"func forward(tensorBatch: TensorBatch, context: NetworkContext) -> TensorBatch","type":"method"},{"path":"\/documentation\/neuron\/layer\/importweights(_:)","title":"func importWeights([Tensor]) throws","type":"method"}],"path":"\/documentation\/neuron\/layer","title":"Layer","type":"protocol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/metriclogger\/lock","title":"var lock: NSLock","type":"property"},{"path":"\/documentation\/neuron\/metriclogger\/metrics","title":"var metrics: [Metric : Tensor.Scalar]","type":"property"},{"path":"\/documentation\/neuron\/metriclogger\/metricstogather","title":"var metricsToGather: Set<Metric>","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"children":[{"children":[{"path":"\/documentation\/neuron\/metriclogger\/addmetric(value:key:)-9r02w","title":"func addMetric(value: Tensor.Scalar, key: Metric)","type":"method"}],"title":"MetricLogger Implementations","type":"groupMarker"}],"path":"\/documentation\/neuron\/metriclogger\/addmetric(value:key:)","title":"func addMetric(value: Tensor.Scalar, key: Metric)","type":"method"}],"path":"\/documentation\/neuron\/metriclogger","title":"MetricLogger","type":"protocol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/optimizer\/batchsize","title":"var batchSize: Int","type":"property"},{"path":"\/documentation\/neuron\/optimizer\/decayfunction","title":"var decayFunction: DecayFunction?","type":"property"},{"path":"\/documentation\/neuron\/optimizer\/device","title":"var device: Device","type":"property"},{"path":"\/documentation\/neuron\/optimizer\/gradientaccumulator","title":"var gradientAccumulator: GradientAccumulator","type":"property"},{"path":"\/documentation\/neuron\/optimizer\/gradientclip","title":"var gradientClip: Tensor.Scalar?","type":"property"},{"path":"\/documentation\/neuron\/optimizer\/istraining","title":"var isTraining: Bool","type":"property"},{"path":"\/documentation\/neuron\/optimizer\/learningrate","title":"var learningRate: Tensor.Scalar","type":"property"},{"path":"\/documentation\/neuron\/optimizer\/metricsreporter","title":"var metricsReporter: MetricsReporter?","type":"property"},{"path":"\/documentation\/neuron\/optimizer\/trainable","title":"var trainable: Trainable","type":"property"},{"path":"\/documentation\/neuron\/optimizer\/weightclip","title":"var weightClip: Tensor.Scalar?","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/optimizer\/apply(_:)","title":"func apply(Tensor.Gradient)","type":"method"},{"path":"\/documentation\/neuron\/optimizer\/callasfunction(_:)","title":"func callAsFunction([Tensor]) -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/optimizer\/fit(_:labels:wrt:lossfunction:validation:requiresgradients:)","title":"func fit([Tensor], labels: [Tensor], wrt: TensorBatch?, lossFunction: LossFunction, validation: Bool, requiresGradients: Bool) -> Output","type":"method"},{"path":"\/documentation\/neuron\/optimizer\/predict(_:)","title":"func predict([Tensor]) -> [Tensor]","type":"method"},{"path":"\/documentation\/neuron\/optimizer\/reset()","title":"func reset()","type":"method"},{"path":"\/documentation\/neuron\/optimizer\/step()","title":"func step()","type":"method"},{"path":"\/documentation\/neuron\/optimizer\/zerogradients()","title":"func zeroGradients()","type":"method"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/neuron\/optimizer\/gradient","title":"Optimizer.Gradient","type":"typealias"},{"path":"\/documentation\/neuron\/optimizer\/output","title":"Optimizer.Output","type":"typealias"}],"path":"\/documentation\/neuron\/optimizer","title":"Optimizer","type":"protocol"},{"children":[{"title":"Associated Types","type":"groupMarker"},{"path":"\/documentation\/neuron\/rnnsupporteddataset\/item","title":"Item","type":"associatedtype"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/rnnsupporteddataset\/vocabsize","title":"var vocabSize: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/rnnsupporteddataset\/build()","title":"func build() async -> RNNSupportedDatasetData","type":"method"},{"path":"\/documentation\/neuron\/rnnsupporteddataset\/getword(for:onehot:)","title":"func getWord(for: Tensor, oneHot: Bool) -> [Item]","type":"method"},{"path":"\/documentation\/neuron\/rnnsupporteddataset\/onehot(_:)","title":"func oneHot([Item]) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/rnnsupporteddataset\/vectorize(_:)","title":"func vectorize([Item]) -> Tensor","type":"method"}],"path":"\/documentation\/neuron\/rnnsupporteddataset","title":"RNNSupportedDataset","type":"protocol"},{"children":[{"title":"Associated Types","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensorrange\/t","title":"T","type":"associatedtype"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensorrange\/range","title":"var range: T","type":"property"}],"path":"\/documentation\/neuron\/tensorrange","title":"TensorRange","type":"protocol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/trainable\/batchsize","title":"var batchSize: Int","type":"property"},{"path":"\/documentation\/neuron\/trainable\/device","title":"var device: Device","type":"property"},{"path":"\/documentation\/neuron\/trainable\/iscompiled","title":"var isCompiled: Bool","type":"property"},{"path":"\/documentation\/neuron\/trainable\/istraining","title":"var isTraining: Bool","type":"property"},{"path":"\/documentation\/neuron\/trainable\/layers","title":"var layers: [Layer]","type":"property"},{"path":"\/documentation\/neuron\/trainable\/name","title":"var name: String","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/trainable\/apply(gradients:learningrate:)","title":"func apply(gradients: Tensor.Gradient, learningRate: Tensor.Scalar)","type":"method"},{"path":"\/documentation\/neuron\/trainable\/compile()","title":"func compile()","type":"method"},{"children":[{"children":[{"path":"\/documentation\/neuron\/trainable\/export(name:overrite:compress:)-4o2t4","title":"func export(name: String?, overrite: Bool, compress: Bool) -> URL?","type":"method"}],"title":"Trainable Implementations","type":"groupMarker"}],"path":"\/documentation\/neuron\/trainable\/export(name:overrite:compress:)","title":"func export(name: String?, overrite: Bool, compress: Bool) -> URL?","type":"method"},{"path":"\/documentation\/neuron\/trainable\/exportweights()","title":"func exportWeights() throws -> [[Tensor]]","type":"method"},{"path":"\/documentation\/neuron\/trainable\/importweights(_:)","title":"func importWeights([[Tensor]]) throws","type":"method"},{"path":"\/documentation\/neuron\/trainable\/predict(_:context:)","title":"func predict(Tensor, context: NetworkContext) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/trainable\/predict(batch:context:)","title":"func predict(batch: TensorBatch, context: NetworkContext) -> TensorBatch","type":"method"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/trainable\/import(_:)","title":"static func `import`(URL) -> Self","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/trainable\/debugdescription","title":"var debugDescription: String","type":"property"}],"path":"\/documentation\/neuron\/trainable\/customdebugstringconvertible-implementations","title":"CustomDebugStringConvertible Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/trainable","title":"Trainable","type":"protocol"},{"children":[{"title":"Associated Types","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorizing\/item","title":"Item","type":"associatedtype"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorizing\/end","title":"var end: Int","type":"property"},{"path":"\/documentation\/neuron\/vectorizing\/inversevector-swift.property","title":"var inverseVector: InverseVector","type":"property"},{"path":"\/documentation\/neuron\/vectorizing\/start","title":"var start: Int","type":"property"},{"path":"\/documentation\/neuron\/vectorizing\/vector-swift.property","title":"var vector: Vector","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorizing\/onehot(_:)","title":"func oneHot([Item]) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/vectorizing\/unvectorize(_:)","title":"func unvectorize([Int]) -> [Item]","type":"method"},{"path":"\/documentation\/neuron\/vectorizing\/unvectorizeonehot(_:)","title":"func unvectorizeOneHot(Tensor) -> [Item]","type":"method"},{"path":"\/documentation\/neuron\/vectorizing\/vectorize(_:format:)","title":"func vectorize([Item], format: VectorFormat) -> [Int]","type":"method"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorizing\/inversevector-swift.typealias","title":"Vectorizing.InverseVector","type":"typealias"},{"path":"\/documentation\/neuron\/vectorizing\/vector-swift.typealias","title":"Vectorizing.Vector","type":"typealias"}],"path":"\/documentation\/neuron\/vectorizing","title":"Vectorizing","type":"protocol"},{"title":"Structures","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/accuracythreshold\/init(value:averagecount:)","title":"init(value: Tensor.Scalar, averageCount: Int)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/accuracythreshold\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/accuracythreshold\/equatable-implementations","title":"Equatable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/accuracythreshold","title":"AccuracyThreshold","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/atomic\/init(wrappedvalue:)","title":"init(wrappedValue: Value)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/atomic\/wrappedvalue","title":"var wrappedValue: Value","type":"property"}],"path":"\/documentation\/neuron\/atomic","title":"Atomic","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/cpu\/init()","title":"init()","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/cpu\/qospriority","title":"var qosPriority: DispatchQoS.QoSClass","type":"property"},{"path":"\/documentation\/neuron\/cpu\/type","title":"var type: DeviceType","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/cpu\/activate(_:_:)","title":"func activate(Tensor, Activation) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/cpu\/conv2d(signal:filter:strides:padding:filtersize:inputsize:outputsize:)","title":"func conv2d(signal: Tensor.Value, filter: Tensor.Value, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), outputSize: (rows: Int, columns: Int)?) -> Tensor.Value","type":"method"},{"path":"\/documentation\/neuron\/cpu\/derivate(_:_:)","title":"func derivate(Tensor, Activation) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/cpu\/matmul(_:_:)","title":"func matmul(Tensor, Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/cpu\/transconv2d(signal:filter:strides:padding:filtersize:inputsize:outputsize:)","title":"func transConv2d(signal: Tensor.Value, filter: Tensor.Value, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), outputSize: (rows: Int, columns: Int)?) -> Tensor.Value","type":"method"}],"path":"\/documentation\/neuron\/cpu","title":"CPU","type":"struct"},{"children":[{"title":"Type Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/constants\/defaultinitializer","title":"static var defaultInitializer: InitializerType","type":"property"},{"path":"\/documentation\/neuron\/constants\/maxworkers","title":"static var maxWorkers: Int","type":"property"}],"path":"\/documentation\/neuron\/constants","title":"Constants","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/datasetmodel\/init(data:label:)","title":"init(data: Tensor, label: Tensor)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/datasetmodel\/data","title":"var data: Tensor","type":"property"},{"path":"\/documentation\/neuron\/datasetmodel\/label","title":"var label: Tensor","type":"property"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/datasetmodel\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/datasetmodel\/equatable-implementations","title":"Equatable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/datasetmodel","title":"DatasetModel","type":"struct"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/exporthelper\/getcsv(filename:_:)","title":"static func getCSV<T>(filename: String, [T]) -> URL?","type":"method"},{"path":"\/documentation\/neuron\/exporthelper\/getmodel(filename:compress:model:)","title":"static func getModel<T>(filename: String, compress: Bool, model: T) -> URL?","type":"method"}],"path":"\/documentation\/neuron\/exporthelper","title":"ExportHelper","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/init(type:)","title":"init(type: InitializerType)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/type","title":"let type: InitializerType","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/calculate(input:out:)","title":"func calculate(input: Int, out: Int) -> Tensor.Scalar","type":"method"},{"path":"\/documentation\/neuron\/initializer\/calculate(size:input:out:)","title":"func calculate(size: TensorSize, input: Int, out: Int) -> Tensor","type":"method"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/henormal","title":"case heNormal","type":"case"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/heuniform","title":"case heUniform","type":"case"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/normal","title":"case normal","type":"case"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/xaviernormal","title":"case xavierNormal","type":"case"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/xavieruniform","title":"case xavierUniform","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/init(intvalue:)","title":"init?(intValue: Int)","type":"init"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/init(stringvalue:)","title":"init?(stringValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/debugdescription","title":"var debugDescription: String","type":"property"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/neuron\/initializer\/codingkeys\/codingkey-implementations","title":"CodingKey Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/initializer\/codingkeys\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/codingkeys\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/initializer\/codingkeys\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/initializer\/codingkeys","title":"Initializer.CodingKeys","type":"enum"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/init(from:)","title":"init(from: Decoder) throws","type":"init"}],"path":"\/documentation\/neuron\/initializer\/decodable-implementations","title":"Decodable Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializer\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"}],"path":"\/documentation\/neuron\/initializer\/encodable-implementations","title":"Encodable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/initializer","title":"Initializer","type":"struct"},{"children":[{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/layer","title":"case layer","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/init(intvalue:)","title":"init?(intValue: Int)","type":"init"},{"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/init(stringvalue:)","title":"init?(stringValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/debugdescription","title":"var debugDescription: String","type":"property"},{"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/description","title":"var description: String","type":"property"}],"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/codingkey-implementations","title":"CodingKey Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/layermodelconverter\/codingkeys","title":"LayerModelConverter.CodingKeys","type":"enum"}],"path":"\/documentation\/neuron\/layermodelconverter","title":"LayerModelConverter","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/networkcontext\/init(indexinbatch:batchrange:batchprocessingcount:totalinbatch:threadid:)","title":"init(indexInBatch: Int, batchRange: CountableRange<Int>, batchProcessingCount: Int, totalInBatch: Int, threadId: UUID)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/networkcontext\/batchprocessingcount","title":"let batchProcessingCount: Int","type":"property"},{"path":"\/documentation\/neuron\/networkcontext\/batchrange","title":"let batchRange: CountableRange<Int>","type":"property"},{"path":"\/documentation\/neuron\/networkcontext\/indexinbatch","title":"let indexInBatch: Int","type":"property"},{"path":"\/documentation\/neuron\/networkcontext\/threadid","title":"let threadId: UUID","type":"property"},{"path":"\/documentation\/neuron\/networkcontext\/totalinbatch","title":"let totalInBatch: Int","type":"property"}],"path":"\/documentation\/neuron\/networkcontext","title":"NetworkContext","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/normaldistribution\/init(randomsource:mean:deviation:)","title":"init(randomSource: GKRandomSource, mean: Tensor.Scalar, deviation: Tensor.Scalar)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/normaldistribution\/deviation","title":"let deviation: Tensor.Scalar","type":"property"},{"path":"\/documentation\/neuron\/normaldistribution\/mean","title":"let mean: Tensor.Scalar","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/normaldistribution\/logprob(value:)","title":"func logProb(value: Tensor.Scalar) -> Tensor.Scalar","type":"method"},{"path":"\/documentation\/neuron\/normaldistribution\/nextscalar()","title":"func nextScalar() -> Tensor.Scalar","type":"method"}],"path":"\/documentation\/neuron\/normaldistribution","title":"NormalDistribution","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensorcontext\/init(backpropagate:)","title":"init(backpropagate: TensorContextFunction?)","type":"init"},{"path":"\/documentation\/neuron\/tensorcontext\/init(from:)","title":"init(from: Decoder) throws","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensorcontext\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensorcontext\/tensorbackpropresult","title":"TensorContext.TensorBackpropResult","type":"typealias"},{"path":"\/documentation\/neuron\/tensorcontext\/tensorcontextfunction","title":"TensorContext.TensorContextFunction","type":"typealias"}],"path":"\/documentation\/neuron\/tensorcontext","title":"TensorContext","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensorsize\/init(array:)","title":"init(array: [Int])","type":"init"},{"path":"\/documentation\/neuron\/tensorsize\/init(from:)","title":"init(from: any Decoder) throws","type":"init"},{"path":"\/documentation\/neuron\/tensorsize\/init(rows:columns:depth:)","title":"init(rows: Int, columns: Int, depth: Int)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensorsize\/asarray","title":"var asArray: [Int]","type":"property"},{"path":"\/documentation\/neuron\/tensorsize\/columns","title":"let columns: Int","type":"property"},{"path":"\/documentation\/neuron\/tensorsize\/depth","title":"let depth: Int","type":"property"},{"path":"\/documentation\/neuron\/tensorsize\/isempty","title":"var isEmpty: Bool","type":"property"},{"path":"\/documentation\/neuron\/tensorsize\/rows","title":"let rows: Int","type":"property"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensorsize\/debugdescription","title":"var debugDescription: String","type":"property"}],"path":"\/documentation\/neuron\/tensorsize\/customdebugstringconvertible-implementations","title":"CustomDebugStringConvertible Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/tensorsize\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/tensorsize\/equatable-implementations","title":"Equatable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/tensorsize","title":"TensorSize","type":"struct"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/neuron\/datatype","title":"DataType","type":"typealias"},{"path":"\/documentation\/neuron\/rnnsupporteddatasetdata","title":"RNNSupportedDatasetData","type":"typealias"},{"path":"\/documentation\/neuron\/resulttype","title":"ResultType","type":"typealias"},{"path":"\/documentation\/neuron\/tensorbatch","title":"TensorBatch","type":"typealias"},{"path":"\/documentation\/neuron\/vectorizableitem","title":"VectorizableItem","type":"typealias"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/activation\/gelu","title":"case geLu","type":"case"},{"path":"\/documentation\/neuron\/activation\/leakyrelu(limit:)","title":"case leakyRelu(limit: Tensor.Scalar)","type":"case"},{"path":"\/documentation\/neuron\/activation\/none","title":"case none","type":"case"},{"path":"\/documentation\/neuron\/activation\/relu","title":"case reLu","type":"case"},{"path":"\/documentation\/neuron\/activation\/selu","title":"case seLu","type":"case"},{"path":"\/documentation\/neuron\/activation\/sigmoid","title":"case sigmoid","type":"case"},{"path":"\/documentation\/neuron\/activation\/softmax","title":"case softmax","type":"case"},{"path":"\/documentation\/neuron\/activation\/swish","title":"case swish","type":"case"},{"path":"\/documentation\/neuron\/activation\/tanh","title":"case tanh","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/activation\/init(from:)","title":"init(from: any Decoder) throws","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/activation\/activate(input:)","title":"func activate(input: Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/activation\/asstring()","title":"func asString() -> String","type":"method"},{"path":"\/documentation\/neuron\/activation\/derivate(_:)","title":"func derivate(Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/activation\/index()","title":"func index() -> Int","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/activation\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/activation\/equatable-implementations","title":"Equatable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/activation","title":"Activation","type":"enum"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/devicetype\/cpu","title":"case cpu","type":"case"},{"path":"\/documentation\/neuron\/devicetype\/gpu","title":"case gpu","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/devicetype\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/devicetype\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/devicetype\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/devicetype\/init(from:)","title":"init(from: any Decoder) throws","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/devicetype\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/devicetype\/encode(to:)","title":"func encode(to: any Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/devicetype\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/devicetype\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/devicetype","title":"DeviceType","type":"enum"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/encodingtype\/avgpool","title":"case avgPool","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/batchnormalize","title":"case batchNormalize","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/conv2d","title":"case conv2d","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/dense","title":"case dense","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/dropout","title":"case dropout","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/embedding","title":"case embedding","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/flatten","title":"case flatten","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/globalavgpool","title":"case globalAvgPool","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/layernormalize","title":"case layerNormalize","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/leakyrelu","title":"case leakyRelu","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/lstm","title":"case lstm","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/maxpool","title":"case maxPool","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/none","title":"case none","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/relu","title":"case relu","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/resnet","title":"case resNet","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/reshape","title":"case reshape","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/selu","title":"case selu","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/sigmoid","title":"case sigmoid","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/softmax","title":"case softmax","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/swish","title":"case swish","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/tanh","title":"case tanh","type":"case"},{"path":"\/documentation\/neuron\/encodingtype\/transconv2d","title":"case transConv2d","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/encodingtype\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/encodingtype\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/encodingtype\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/encodingtype\/init(from:)","title":"init(from: any Decoder) throws","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/encodingtype\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/encodingtype\/encode(to:)","title":"func encode(to: any Encoder) throws","type":"method"},{"path":"\/documentation\/neuron\/encodingtype\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/encodingtype\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/encodingtype","title":"EncodingType","type":"enum"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializertype\/henormal","title":"case heNormal","type":"case"},{"path":"\/documentation\/neuron\/initializertype\/heuniform","title":"case heUniform","type":"case"},{"path":"\/documentation\/neuron\/initializertype\/normal(std:)","title":"case normal(std: Tensor.Scalar)","type":"case"},{"path":"\/documentation\/neuron\/initializertype\/xaviernormal","title":"case xavierNormal","type":"case"},{"path":"\/documentation\/neuron\/initializertype\/xavieruniform","title":"case xavierUniform","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializertype\/init(from:)","title":"init(from: any Decoder) throws","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializertype\/build()","title":"func build() -> Initializer","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/initializertype\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/initializertype\/equatable-implementations","title":"Equatable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/initializertype","title":"InitializerType","type":"enum"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/layererrors\/generic(error:)","title":"case generic(error: String)","type":"case"},{"path":"\/documentation\/neuron\/layererrors\/weightimporterror","title":"case weightImportError","type":"case"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layererrors\/errordescription","title":"var errorDescription: String?","type":"property"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layererrors\/localizeddescription","title":"var localizedDescription: String","type":"property"}],"path":"\/documentation\/neuron\/layererrors\/error-implementations","title":"Error Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/layererrors\/failurereason","title":"var failureReason: String?","type":"property"},{"path":"\/documentation\/neuron\/layererrors\/helpanchor","title":"var helpAnchor: String?","type":"property"},{"path":"\/documentation\/neuron\/layererrors\/recoverysuggestion","title":"var recoverySuggestion: String?","type":"property"}],"path":"\/documentation\/neuron\/layererrors\/localizederror-implementations","title":"LocalizedError Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/layererrors","title":"LayerErrors","type":"enum"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/lossfunction\/binarycrossentropy","title":"case binaryCrossEntropy","type":"case"},{"path":"\/documentation\/neuron\/lossfunction\/binarycrossentropysoftmax","title":"case binaryCrossEntropySoftmax","type":"case"},{"path":"\/documentation\/neuron\/lossfunction\/crossentropy","title":"case crossEntropy","type":"case"},{"path":"\/documentation\/neuron\/lossfunction\/crossentropysoftmax","title":"case crossEntropySoftmax","type":"case"},{"path":"\/documentation\/neuron\/lossfunction\/meansquareerror","title":"case meanSquareError","type":"case"},{"path":"\/documentation\/neuron\/lossfunction\/minimaxbinarycrossentropy","title":"case minimaxBinaryCrossEntropy","type":"case"},{"path":"\/documentation\/neuron\/lossfunction\/wasserstein","title":"case wasserstein","type":"case"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/lossfunction\/calculate(_:correct:)-42cmw","title":"func calculate([Tensor.Scalar], correct: [Tensor.Scalar]) -> Tensor.Scalar","type":"method"},{"path":"\/documentation\/neuron\/lossfunction\/calculate(_:correct:)-9jyyy","title":"func calculate(Tensor, correct: Tensor) -> Tensor","type":"method"},{"path":"\/documentation\/neuron\/lossfunction\/derivative(_:correct:)-38iw3","title":"func derivative([Tensor.Scalar], correct: [Tensor.Scalar]) -> [Tensor.Scalar]","type":"method"},{"path":"\/documentation\/neuron\/lossfunction\/derivative(_:correct:)-6ucnp","title":"func derivative(Tensor, correct: Tensor) -> Tensor","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/lossfunction\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/lossfunction\/equatable-implementations","title":"Equatable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/lossfunction","title":"LossFunction","type":"enum"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/metric\/accuracy","title":"case accuracy","type":"case"},{"path":"\/documentation\/neuron\/metric\/batchconcurrency","title":"case batchConcurrency","type":"case"},{"path":"\/documentation\/neuron\/metric\/batchtime","title":"case batchTime","type":"case"},{"path":"\/documentation\/neuron\/metric\/criticloss","title":"case criticLoss","type":"case"},{"path":"\/documentation\/neuron\/metric\/fakeimageloss","title":"case fakeImageLoss","type":"case"},{"path":"\/documentation\/neuron\/metric\/generatorloss","title":"case generatorLoss","type":"case"},{"path":"\/documentation\/neuron\/metric\/gradientpenalty","title":"case gradientPenalty","type":"case"},{"path":"\/documentation\/neuron\/metric\/loss","title":"case loss","type":"case"},{"path":"\/documentation\/neuron\/metric\/optimizerruntime","title":"case optimizerRunTime","type":"case"},{"path":"\/documentation\/neuron\/metric\/realimageloss","title":"case realImageLoss","type":"case"},{"path":"\/documentation\/neuron\/metric\/valaccuracy","title":"case valAccuracy","type":"case"},{"path":"\/documentation\/neuron\/metric\/valloss","title":"case valLoss","type":"case"},{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/neuron\/metric\/init(rawvalue:)","title":"init?(rawValue: String)","type":"init"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/metric\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/metric\/equatable-implementations","title":"Equatable Implementations","type":"symbol"},{"children":[{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/neuron\/metric\/hashvalue","title":"var hashValue: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/neuron\/metric\/hash(into:)","title":"func hash(into: inout Hasher)","type":"method"}],"path":"\/documentation\/neuron\/metric\/rawrepresentable-implementations","title":"RawRepresentable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/metric","title":"Metric","type":"enum"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorformat\/end","title":"case end","type":"case"},{"path":"\/documentation\/neuron\/vectorformat\/none","title":"case none","type":"case"},{"path":"\/documentation\/neuron\/vectorformat\/start","title":"case start","type":"case"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/neuron\/vectorformat\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/neuron\/vectorformat\/equatable-implementations","title":"Equatable Implementations","type":"symbol"}],"path":"\/documentation\/neuron\/vectorformat","title":"VectorFormat","type":"enum"}],"path":"\/documentation\/neuron","title":"Neuron","type":"module"},{"children":[{"title":"Classes","type":"groupMarker"},{"children":[{"title":"Classes","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswift\/gpu\/init()","title":"init()","type":"init"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswift\/gpu\/matrixmult(a:b:)","title":"func matrixMult(a: GPUData, b: GPUData) -> [Float]","type":"method"}],"path":"\/documentation\/numswift\/numswift\/gpu","title":"NumSwift.GPU","type":"class"},{"title":"Type Aliases","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswift\/gpudata","title":"NumSwift.GPUData","type":"typealias"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswift\/oneslike(_:)-1lbgn","title":"static func onesLike((rows: Int, columns: Int, depth: Int)) -> [[[Float]]]","type":"method"},{"path":"\/documentation\/numswift\/numswift\/oneslike(_:)-20b4o","title":"static func onesLike((rows: Int, columns: Int)) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswift\/oneslike(_:)-5kd2u","title":"static func onesLike((rows: Int, columns: Int, depth: Int)) -> [[[Float16]]]","type":"method"},{"path":"\/documentation\/numswift\/numswift\/oneslike(_:)-6oa6q","title":"static func onesLike((rows: Int, columns: Int)) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswift\/oneslike(_:)-7px47","title":"static func onesLike((rows: Int, columns: Int)) -> [[Double]]","type":"method"},{"path":"\/documentation\/numswift\/numswift\/oneslike(_:)-anwy","title":"static func onesLike<T>(T) -> Array<AnyHashable>","type":"method"},{"path":"\/documentation\/numswift\/numswift\/randomchoice(in:p:)-5meql","title":"static func randomChoice<T>(in: [T], p: [Float16]) -> (T, Int)","type":"method"},{"path":"\/documentation\/numswift\/numswift\/randomchoice(in:p:)-69w34","title":"static func randomChoice<T>(in: [T], p: [Float]) -> (T, Int)","type":"method"},{"path":"\/documentation\/numswift\/numswift\/zeroslike(_:)-1b5c3","title":"static func zerosLike((rows: Int, columns: Int)) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswift\/zeroslike(_:)-1jear","title":"static func zerosLike<T>(T) -> Array<AnyHashable>","type":"method"},{"path":"\/documentation\/numswift\/numswift\/zeroslike(_:)-505hm","title":"static func zerosLike((rows: Int, columns: Int)) -> [[Double]]","type":"method"},{"path":"\/documentation\/numswift\/numswift\/zeroslike(_:)-5dn1y","title":"static func zerosLike((rows: Int, columns: Int, depth: Int)) -> [[[Float]]]","type":"method"},{"path":"\/documentation\/numswift\/numswift\/zeroslike(_:)-8lvwn","title":"static func zerosLike((rows: Int, columns: Int)) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswift\/zeroslike(_:)-9liae","title":"static func zerosLike((rows: Int, columns: Int, depth: Int)) -> [[[Float16]]]","type":"method"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Enumeration Cases","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswift\/convpadding\/same","title":"case same","type":"case"},{"path":"\/documentation\/numswift\/numswift\/convpadding\/valid","title":"case valid","type":"case"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswift\/convpadding\/extra(inputsize:filtersize:stride:)","title":"func extra(inputSize: (Int, Int), filterSize: (Int, Int), stride: (Int, Int)) -> (top: Int, bottom: Int, left: Int, right: Int)","type":"method"},{"title":"Default Implementations","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswift\/convpadding\/init(from:)","title":"init(from: Decoder) throws","type":"init"}],"path":"\/documentation\/numswift\/numswift\/convpadding\/decodable-implementations","title":"Decodable Implementations","type":"symbol"},{"children":[{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswift\/convpadding\/encode(to:)","title":"func encode(to: Encoder) throws","type":"method"}],"path":"\/documentation\/numswift\/numswift\/convpadding\/encodable-implementations","title":"Encodable Implementations","type":"symbol"},{"children":[{"title":"Operators","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswift\/convpadding\/!=(_:_:)","title":"static func != (Self, Self) -> Bool","type":"op"}],"path":"\/documentation\/numswift\/numswift\/convpadding\/equatable-implementations","title":"Equatable Implementations","type":"symbol"}],"path":"\/documentation\/numswift\/numswift\/convpadding","title":"NumSwift.ConvPadding","type":"enum"}],"path":"\/documentation\/numswift\/numswift","title":"NumSwift","type":"class"},{"title":"Protocols","type":"groupMarker"},{"children":[{"title":"Associated Types","type":"groupMarker"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/scalar","title":"Scalar","type":"associatedtype"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/value","title":"Value","type":"associatedtype"},{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/add(lhs:rhs:)-13gma","title":"static func add(lhs: Scalar, rhs: Value) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/add(lhs:rhs:)-88z3w","title":"static func add(lhs: Value, rhs: Value) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/div(lhs:rhs:)-2szv4","title":"static func div(lhs: Value, rhs: Scalar) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/div(lhs:rhs:)-4qd4g","title":"static func div(lhs: Scalar, rhs: Value) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/div(lhs:rhs:)-o3pd","title":"static func div(lhs: Value, rhs: Value) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/indexofmax(_:)","title":"static func indexOfMax(Value) -> (UInt, Scalar)","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/indexofmin(_:)","title":"static func indexOfMin(Value) -> (UInt, Scalar)","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/max(_:)","title":"static func max(Value) -> Scalar","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/mean(_:)","title":"static func mean(Value) -> Scalar","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/min(_:)","title":"static func min(Value) -> Scalar","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/mult(lhs:rhs:)-43gxx","title":"static func mult(lhs: Value, rhs: Scalar) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/mult(lhs:rhs:)-62d2k","title":"static func mult(lhs: Value, rhs: Value) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/mult(lhs:rhs:)-7ccmj","title":"static func mult(lhs: Scalar, rhs: Value) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/sub(lhs:rhs:)-33zmu","title":"static func sub(lhs: Value, rhs: Value) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/sub(lhs:rhs:)-j81c","title":"static func sub(lhs: Scalar, rhs: Value) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/sub(lhs:rhs:)-whbz","title":"static func sub(lhs: Value, rhs: Scalar) -> Value","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/sum(_:)","title":"static func sum(Value) -> Scalar","type":"method"},{"path":"\/documentation\/numswift\/floatarithmeticbase\/sumofsquares(_:)","title":"static func sumOfSquares(Value) -> Scalar","type":"method"}],"path":"\/documentation\/numswift\/floatarithmeticbase","title":"FloatArithmeticBase","type":"protocol"},{"title":"Structures","type":"groupMarker"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/numswift\/noisec\/init(size:octaves:amplitude:)","title":"init(size: Int, octaves: Int, amplitude: Double)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/numswift\/noisec\/amplitude","title":"var amplitude: Double","type":"property"},{"path":"\/documentation\/numswift\/noisec\/octaves","title":"var octaves: Int","type":"property"},{"title":"Instance Methods","type":"groupMarker"},{"path":"\/documentation\/numswift\/noisec\/nextperlin(x:y:z:)","title":"func nextPerlin(x: Double, y: Double, z: Double) -> Double","type":"method"}],"path":"\/documentation\/numswift\/noisec","title":"NoiseC","type":"struct"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswiftc\/add(_:_:)-3xo0t","title":"static func add([[Float16]], [[Float16]]) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/add(_:_:)-9in6c","title":"static func add([[Float]], [[Float]]) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/add(_:array:)-2e2wf","title":"static func add([[Float]], array: [Float]) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/add(_:array:)-xs12","title":"static func add([[Float16]], array: [Float16]) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/add(_:scalar:)-84u0z","title":"static func add([[Float16]], scalar: Float16) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/add(_:scalar:)-9wf9g","title":"static func add([[Float]], scalar: Float) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/conv1d(signal:filter:strides:padding:filtersize:inputsize:)-4hcof","title":"static func conv1d(signal: [Float16], filter: [Float16], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/conv1d(signal:filter:strides:padding:filtersize:inputsize:)-6qhcm","title":"static func conv1d(signal: [Float], filter: [Float], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/conv2d(signal:filter:strides:padding:filtersize:inputsize:)-3qccg","title":"static func conv2d(signal: [[Float]], filter: [[Float]], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/conv2d(signal:filter:strides:padding:filtersize:inputsize:)-7btbz","title":"static func conv2d(signal: [[Float16]], filter: [[Float16]], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/divide(_:_:)-28xpz","title":"static func divide([[Float16]], [[Float16]]) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/divide(_:_:)-2itv3","title":"static func divide([[Float]], [[Float]]) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/divide(_:array:)-4e1jq","title":"static func divide([[Float16]], array: [Float16]) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/divide(_:array:)-5ob0f","title":"static func divide([[Float]], array: [Float]) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/divide(_:scalar:)-13m17","title":"static func divide([[Float]], scalar: Float) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/divide(_:scalar:)-9anhz","title":"static func divide([[Float16]], scalar: Float16) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/flatten(_:inputsize:)-5jaod","title":"static func flatten([[Float16]], inputSize: (rows: Int, columns: Int)?) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/flatten(_:inputsize:)-6exxl","title":"static func flatten([[[Float16]]], inputSize: (rows: Int, columns: Int, depth: Int)?) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/flatten(_:inputsize:)-6neu","title":"static func flatten([[[Float]]], inputSize: (rows: Int, columns: Int, depth: Int)?) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/flatten(_:inputsize:)-8gy5x","title":"static func flatten([[Float]], inputSize: (rows: Int, columns: Int)?) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/matmul(_:b:asize:bsize:)-5v2ym","title":"static func matmul([[Float16]], b: [[Float16]], aSize: (rows: Int, columns: Int), bSize: (rows: Int, columns: Int)) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/matmul(_:b:asize:bsize:)-6ya05","title":"static func matmul([[Float]], b: [[Float]], aSize: (rows: Int, columns: Int), bSize: (rows: Int, columns: Int)) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/matmul1d(_:b:asize:bsize:)-7r1qd","title":"static func matmul1d([Float], b: [Float], aSize: (rows: Int, columns: Int), bSize: (rows: Int, columns: Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/matmul1d(_:b:asize:bsize:)-9jlcx","title":"static func matmul1d([Float16], b: [Float16], aSize: (rows: Int, columns: Int), bSize: (rows: Int, columns: Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/mult(_:_:)-3nqa0","title":"static func mult([[Float16]], [[Float16]]) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/mult(_:_:)-6ulqs","title":"static func mult([[Float]], [[Float]]) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/mult(_:array:)-1evq9","title":"static func mult([[Float]], array: [Float]) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/mult(_:array:)-48ea8","title":"static func mult([[Float16]], array: [Float16]) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/mult(_:scalar:)-7l7j4","title":"static func mult([[Float]], scalar: Float) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/mult(_:scalar:)-88pun","title":"static func mult([[Float16]], scalar: Float16) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/paddingcalculation(strides:padding:filtersize:inputsize:)","title":"static func paddingCalculation(strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> (top: Int, bottom: Int, left: Int, right: Int)","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/stridepad(signal:strides:)-5ut9k","title":"static func stridePad(signal: [[Float]], strides: (rows: Int, columns: Int)) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/stridepad(signal:strides:)-7kgqp","title":"static func stridePad(signal: [[Float16]], strides: (rows: Int, columns: Int)) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/stridepad1d(signal:strides:)-35vdj","title":"static func stridePad1D(signal: [Float], strides: (rows: Int, columns: Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/stridepad1d(signal:strides:)-mzbk","title":"static func stridePad1D(signal: [Float16], strides: (rows: Int, columns: Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/sub(_:_:)-3o238","title":"static func sub([[Float]], [[Float]]) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/sub(_:_:)-61qhb","title":"static func sub([[Float16]], [[Float16]]) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/sub(_:array:)-2kaem","title":"static func sub([[Float16]], array: [Float16]) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/sub(_:array:)-83qlv","title":"static func sub([[Float]], array: [Float]) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/sub(_:scalar:)-3mda","title":"static func sub([[Float]], scalar: Float) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/sub(_:scalar:)-5ou3j","title":"static func sub([[Float16]], scalar: Float16) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/tranpose(_:size:)-8kx4j","title":"static func tranpose([[Float]], size: (rows: Int, columns: Int)) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/tranpose(_:size:)-omeq","title":"static func tranpose([[Float16]], size: (rows: Int, columns: Int)) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/transconv1d(signal:filter:strides:padding:filtersize:inputsize:)-2gu0x","title":"static func transConv1d(signal: [Float16], filter: [Float16], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/transconv1d(signal:filter:strides:padding:filtersize:inputsize:)-59vw4","title":"static func transConv1d(signal: [Float], filter: [Float], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/transconv2d(signal:filter:strides:padding:filtersize:inputsize:)-1wza7","title":"static func transConv2d(signal: [[Float]], filter: [[Float]], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/transconv2d(signal:filter:strides:padding:filtersize:inputsize:)-71v8g","title":"static func transConv2d(signal: [[Float16]], filter: [[Float16]], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/zeropad(signal:filtersize:inputsize:stride:)-20rtb","title":"static func zeroPad(signal: [[Float]], filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), stride: (Int, Int)) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/zeropad(signal:filtersize:inputsize:stride:)-4dzdt","title":"static func zeroPad(signal: [[Float16]], filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), stride: (Int, Int)) -> [[Float16]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/zeropad(signal:filtersize:inputsize:stride:)-5hkc1","title":"static func zeroPad(signal: [Float], filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), stride: (Int, Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/zeropad(signal:filtersize:inputsize:stride:)-8bk7c","title":"static func zeroPad(signal: [Float16], filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), stride: (Int, Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/zeropad(signal:padding:)-5eqvv","title":"static func zeroPad(signal: [[Float]], padding: NumSwiftPadding) -> [[Float]]","type":"method"},{"path":"\/documentation\/numswift\/numswiftc\/zeropad(signal:padding:)-9hc05","title":"static func zeroPad(signal: [[Float16]], padding: NumSwiftPadding) -> [[Float16]]","type":"method"}],"path":"\/documentation\/numswift\/numswiftc","title":"NumSwiftC","type":"struct"},{"children":[{"title":"Initializers","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswiftpadding\/init(top:left:right:bottom:)","title":"init(top: Int, left: Int, right: Int, bottom: Int)","type":"init"},{"title":"Instance Properties","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswiftpadding\/bottom","title":"var bottom: Int","type":"property"},{"path":"\/documentation\/numswift\/numswiftpadding\/left","title":"var left: Int","type":"property"},{"path":"\/documentation\/numswift\/numswiftpadding\/right","title":"var right: Int","type":"property"},{"path":"\/documentation\/numswift\/numswiftpadding\/top","title":"var top: Int","type":"property"}],"path":"\/documentation\/numswift\/numswiftpadding","title":"NumSwiftPadding","type":"struct"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/numswift\/numswiftflat\/clip(_:to:)-2n66i","title":"static func clip(ContiguousArray<Float>, to: Float) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/clip(_:to:)-5mxag","title":"static func clip(ContiguousArray<Float16>, to: Float16) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/clip(_:to:)-9rpyy","title":"static func clip([Float16], to: Float16) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/clip(_:to:)-xhao","title":"static func clip([Float], to: Float) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/conv2d(signal:filter:strides:padding:filtersize:inputsize:)-4m5lj","title":"static func conv2d(signal: [Float16], filter: [Float16], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/conv2d(signal:filter:strides:padding:filtersize:inputsize:)-6toyi","title":"static func conv2d(signal: [Float], filter: [Float], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/conv2d(signal:filter:strides:padding:filtersize:inputsize:)-6zl6a","title":"static func conv2d(signal: ContiguousArray<Float>, filter: ContiguousArray<Float>, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/conv2d(signal:filter:strides:padding:filtersize:inputsize:)-7nxcn","title":"static func conv2d(signal: ContiguousArray<Float16>, filter: ContiguousArray<Float16>, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/flip180(_:rows:columns:)-3ikjt","title":"static func flip180([Float], rows: Int, columns: Int) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/flip180(_:rows:columns:)-443sr","title":"static func flip180(ContiguousArray<Float>, rows: Int, columns: Int) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/flip180(_:rows:columns:)-48niv","title":"static func flip180(ContiguousArray<Float16>, rows: Int, columns: Int) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/flip180(_:rows:columns:)-5u2i8","title":"static func flip180([Float16], rows: Int, columns: Int) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/matmul(_:_:arows:acols:brows:bcols:)-231v2","title":"static func matmul([Float], [Float], aRows: Int, aCols: Int, bRows: Int, bCols: Int) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/matmul(_:_:arows:acols:brows:bcols:)-2lorq","title":"static func matmul(ContiguousArray<Float>, ContiguousArray<Float>, aRows: Int, aCols: Int, bRows: Int, bCols: Int) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/matmul(_:_:arows:acols:brows:bcols:)-3fsxw","title":"static func matmul([Float16], [Float16], aRows: Int, aCols: Int, bRows: Int, bCols: Int) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/matmul(_:_:arows:acols:brows:bcols:)-7mn6f","title":"static func matmul(ContiguousArray<Float16>, ContiguousArray<Float16>, aRows: Int, aCols: Int, bRows: Int, bCols: Int) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/negate(_:)-1py8e","title":"static func negate(ContiguousArray<Float16>) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/negate(_:)-208ec","title":"static func negate([Float]) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/negate(_:)-3x9bd","title":"static func negate(ContiguousArray<Float>) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/negate(_:)-phjs","title":"static func negate([Float16]) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/paddingcalculation(strides:padding:filtersize:inputsize:)","title":"static func paddingCalculation(strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> (top: Int, bottom: Int, left: Int, right: Int)","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/sqrt(_:)-1c2yk","title":"static func sqrt([Float]) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/sqrt(_:)-1qieu","title":"static func sqrt(ContiguousArray<Float>) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/sqrt(_:)-4d727","title":"static func sqrt([Float16]) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/sqrt(_:)-9p7ll","title":"static func sqrt(ContiguousArray<Float16>) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/stridepad(signal:strides:inputsize:)-2fajp","title":"static func stridePad(signal: ContiguousArray<Float>, strides: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/stridepad(signal:strides:inputsize:)-3ggby","title":"static func stridePad(signal: [Float16], strides: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/stridepad(signal:strides:inputsize:)-5a5bt","title":"static func stridePad(signal: ContiguousArray<Float16>, strides: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/stridepad(signal:strides:inputsize:)-6ixhg","title":"static func stridePad(signal: [Float], strides: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/stridepadshape(inputsize:strides:)","title":"static func stridePadShape(inputSize: (rows: Int, columns: Int), strides: (rows: Int, columns: Int)) -> (rows: Int, columns: Int)","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/sumofsquares(_:)","title":"static func sumOfSquares(ContiguousArray<Float>) -> Float","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/transconv2d(signal:filter:strides:padding:filtersize:inputsize:)-1v8z4","title":"static func transConv2d(signal: [Float], filter: [Float], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/transconv2d(signal:filter:strides:padding:filtersize:inputsize:)-4h9rp","title":"static func transConv2d(signal: ContiguousArray<Float16>, filter: ContiguousArray<Float16>, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/transconv2d(signal:filter:strides:padding:filtersize:inputsize:)-4irea","title":"static func transConv2d(signal: [Float16], filter: [Float16], strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/transconv2d(signal:filter:strides:padding:filtersize:inputsize:)-4kosj","title":"static func transConv2d(signal: ContiguousArray<Float>, filter: ContiguousArray<Float>, strides: (Int, Int), padding: NumSwift.ConvPadding, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int)) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/transpose(_:rows:columns:)-66zof","title":"static func transpose(ContiguousArray<Float>, rows: Int, columns: Int) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/transpose(_:rows:columns:)-6d5lw","title":"static func transpose([Float16], rows: Int, columns: Int) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/transpose(_:rows:columns:)-7uzbt","title":"static func transpose(ContiguousArray<Float16>, rows: Int, columns: Int) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/transpose(_:rows:columns:)-8djvu","title":"static func transpose([Float], rows: Int, columns: Int) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/zeropad(signal:filtersize:inputsize:stride:)-38vff","title":"static func zeroPad(signal: [Float], filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), stride: (Int, Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/zeropad(signal:filtersize:inputsize:stride:)-3umy6","title":"static func zeroPad(signal: ContiguousArray<Float>, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), stride: (Int, Int)) -> ContiguousArray<Float>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/zeropad(signal:filtersize:inputsize:stride:)-4u2mj","title":"static func zeroPad(signal: ContiguousArray<Float16>, filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), stride: (Int, Int)) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/zeropad(signal:filtersize:inputsize:stride:)-9or1f","title":"static func zeroPad(signal: [Float16], filterSize: (rows: Int, columns: Int), inputSize: (rows: Int, columns: Int), stride: (Int, Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/zeropad(signal:padding:inputsize:)-2m9q4","title":"static func zeroPad(signal: ContiguousArray<Float16>, padding: NumSwiftPadding, inputSize: (rows: Int, columns: Int)) -> ContiguousArray<Float16>","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/zeropad(signal:padding:inputsize:)-3n90v","title":"static func zeroPad(signal: [Float], padding: NumSwiftPadding, inputSize: (rows: Int, columns: Int)) -> [Float]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/zeropad(signal:padding:inputsize:)-48s4b","title":"static func zeroPad(signal: [Float16], padding: NumSwiftPadding, inputSize: (rows: Int, columns: Int)) -> [Float16]","type":"method"},{"path":"\/documentation\/numswift\/numswiftflat\/zeropad(signal:padding:inputsize:)-4rzu8","title":"static func zeroPad(signal: ContiguousArray<Float>, padding: NumSwiftPadding, inputSize: (rows: Int, columns: Int)) -> ContiguousArray<Float>","type":"method"}],"path":"\/documentation\/numswift\/numswiftflat","title":"NumSwiftFlat","type":"enum"}],"path":"\/documentation\/numswift","title":"NumSwift","type":"module"},{"children":[{"title":"Protocols","type":"groupMarker"},{"children":[{"title":"Operators","type":"groupMarker"},{"children":[{"children":[{"path":"\/documentation\/numerics\/algebraicfield\/_(_:_:)-9bcy2","title":"static func \/ (Self, Self) -> Self","type":"op"},{"path":"\/documentation\/numerics\/algebraicfield\/_(_:_:)-9bcy2","title":"static func \/ (Self, Self) -> Self","type":"op"}],"title":"AlgebraicField Implementations","type":"groupMarker"}],"path":"\/documentation\/numerics\/algebraicfield\/_(_:_:)","title":"static func \/ (Self, Self) -> Self","type":"op"},{"path":"\/documentation\/numerics\/algebraicfield\/_=(_:_:)","title":"static func \/= (inout Self, Self)","type":"op"},{"title":"Instance Properties","type":"groupMarker"},{"children":[{"children":[{"path":"\/documentation\/numerics\/algebraicfield\/reciprocal-5zww8","title":"var reciprocal: Self?","type":"property"},{"path":"\/documentation\/numerics\/algebraicfield\/reciprocal-5zww8","title":"var reciprocal: Self?","type":"property"},{"path":"\/documentation\/numerics\/algebraicfield\/reciprocal-6sp2m","title":"var reciprocal: Self?","type":"property"},{"path":"\/documentation\/numerics\/algebraicfield\/reciprocal-6sp2m","title":"var reciprocal: Self?","type":"property"}],"title":"AlgebraicField Implementations","type":"groupMarker"}],"path":"\/documentation\/numerics\/algebraicfield\/reciprocal","title":"var reciprocal: Self?","type":"property"}],"path":"\/documentation\/numerics\/algebraicfield","title":"AlgebraicField","type":"protocol"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/numerics\/elementaryfunctions\/acos(_:)","title":"static func acos(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/acosh(_:)","title":"static func acosh(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/asin(_:)","title":"static func asin(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/asinh(_:)","title":"static func asinh(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/atan(_:)","title":"static func atan(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/atanh(_:)","title":"static func atanh(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/cos(_:)","title":"static func cos(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/cosh(_:)","title":"static func cosh(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/exp(_:)","title":"static func exp(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/expminusone(_:)","title":"static func expMinusOne(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/log(_:)","title":"static func log(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/log(oneplus:)","title":"static func log(onePlus: Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/pow(_:_:)-2qmul","title":"static func pow(Self, Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/pow(_:_:)-9imp6","title":"static func pow(Self, Int) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/root(_:_:)","title":"static func root(Self, Int) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/sin(_:)","title":"static func sin(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/sinh(_:)","title":"static func sinh(Self) -> Self","type":"method"},{"children":[{"children":[{"path":"\/documentation\/numerics\/elementaryfunctions\/sqrt(_:)-579s1","title":"static func sqrt(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/sqrt(_:)-579s1","title":"static func sqrt(Self) -> Self","type":"method"}],"title":"ElementaryFunctions Implementations","type":"groupMarker"}],"path":"\/documentation\/numerics\/elementaryfunctions\/sqrt(_:)","title":"static func sqrt(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/tan(_:)","title":"static func tan(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/elementaryfunctions\/tanh(_:)","title":"static func tanh(Self) -> Self","type":"method"}],"path":"\/documentation\/numerics\/elementaryfunctions","title":"ElementaryFunctions","type":"protocol"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/numerics\/real\/cosminusone(_:)","title":"static func cosMinusOne(Self) -> Self","type":"method"}],"path":"\/documentation\/numerics\/real","title":"Real","type":"protocol"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/numerics\/realfunctions\/atan2(y:x:)","title":"static func atan2(y: Self, x: Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/erf(_:)","title":"static func erf(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/erfc(_:)","title":"static func erfc(Self) -> Self","type":"method"},{"children":[{"children":[{"path":"\/documentation\/numerics\/realfunctions\/exp10(_:)-3zh0i","title":"static func exp10(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/exp10(_:)-3zh0i","title":"static func exp10(Self) -> Self","type":"method"}],"title":"RealFunctions Implementations","type":"groupMarker"}],"path":"\/documentation\/numerics\/realfunctions\/exp10(_:)","title":"static func exp10(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/exp2(_:)","title":"static func exp2(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/gamma(_:)","title":"static func gamma(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/hypot(_:_:)","title":"static func hypot(Self, Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/log10(_:)","title":"static func log10(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/log2(_:)","title":"static func log2(Self) -> Self","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/loggamma(_:)","title":"static func logGamma(Self) -> Self","type":"method"},{"children":[{"children":[{"path":"\/documentation\/numerics\/realfunctions\/signgamma(_:)-53fqx","title":"static func signGamma(Self) -> FloatingPointSign","type":"method"},{"path":"\/documentation\/numerics\/realfunctions\/signgamma(_:)-53fqx","title":"static func signGamma(Self) -> FloatingPointSign","type":"method"}],"title":"RealFunctions Implementations","type":"groupMarker"}],"path":"\/documentation\/numerics\/realfunctions\/signgamma(_:)","title":"static func signGamma(Self) -> FloatingPointSign","type":"method"}],"path":"\/documentation\/numerics\/realfunctions","title":"RealFunctions","type":"protocol"},{"title":"Enumerations","type":"groupMarker"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/numerics\/augmented\/product(_:_:)","title":"static func product<T>(T, T) -> (head: T, tail: T)","type":"method"},{"path":"\/documentation\/numerics\/augmented\/sum(_:_:)","title":"static func sum<T>(T, T) -> (head: T, tail: T)","type":"method"},{"path":"\/documentation\/numerics\/augmented\/sum(large:small:)","title":"static func sum<T>(large: T, small: T) -> (head: T, tail: T)","type":"method"}],"path":"\/documentation\/numerics\/augmented","title":"Augmented","type":"enum"},{"children":[{"title":"Type Methods","type":"groupMarker"},{"path":"\/documentation\/numerics\/relaxed\/multiplyadd(_:_:_:)","title":"static func multiplyAdd<T>(T, T, T) -> T","type":"method"},{"path":"\/documentation\/numerics\/relaxed\/product(_:_:)","title":"static func product<T>(T, T) -> T","type":"method"},{"path":"\/documentation\/numerics\/relaxed\/sum(_:_:)","title":"static func sum<T>(T, T) -> T","type":"method"}],"path":"\/documentation\/numerics\/relaxed","title":"Relaxed","type":"enum"}],"path":"\/documentation\/numerics","title":"Numerics","type":"module"},{"path":"\/documentation\/realmodule","title":"RealModule","type":"module"}]},"schemaVersion":{"major":0,"minor":1,"patch":2}}